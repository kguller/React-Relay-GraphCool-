import { Children, Component, PureComponent, createElement } from 'react';
import * as React from 'react';
import { classNames, variationName } from '@shopify/react-utilities/styles';
import { __decorate, __rest } from 'tslib';
import * as tslib_1 from 'tslib';
import { classNames as classNames$1, variationName as variationName$1 } from '@shopify/react-utilities';
import { elementChildren, isElementOfType, layeredComponent, wrapWithComponent } from '@shopify/react-utilities/components';
import autobind from '@shopify/javascript-utilities/autobind';
import { createUniqueIDFactory, noop } from '@shopify/javascript-utilities/other';
import { bool, object } from 'prop-types';
import * as PropTypes from 'prop-types';
import { addEventListener, removeEventListener } from '@shopify/javascript-utilities/events';
import { read, write } from '@shopify/javascript-utilities/fastdom';
import { clamp } from '@shopify/javascript-utilities/math';
import { Months, Weekdays, abbreviationForWeekday, dateIsInRange, dateIsSelected, getNewRange, getNextDisplayMonth, getNextDisplayYear, getPreviousDisplayMonth, getPreviousDisplayYear, getWeeksForMonth, isDateAfter, isDateBefore, isSameDay } from '@shopify/javascript-utilities/dates';
import isEqual from 'lodash/isEqual';
import pick from 'lodash/pick';
import { findFirstFocusableNode, focusFirstFocusableNode } from '@shopify/javascript-utilities/focus';
import { closest, nodeContainsDescendant } from '@shopify/javascript-utilities/dom';
import { TransitionGroup, TransitionStatus } from '@shopify/react-utilities/animation';
import { Rect, getRectForNode } from '@shopify/javascript-utilities/geometry';
import { findDOMNode } from 'react-dom';

var Keys;
(function (Keys) {
    Keys[Keys["BACKSPACE"] = 8] = "BACKSPACE";
    Keys[Keys["TAB"] = 9] = "TAB";
    Keys[Keys["ENTER"] = 13] = "ENTER";
    Keys[Keys["SHIFT"] = 16] = "SHIFT";
    Keys[Keys["CTRL"] = 17] = "CTRL";
    Keys[Keys["ALT"] = 18] = "ALT";
    Keys[Keys["PAUSE"] = 19] = "PAUSE";
    Keys[Keys["CAPS_LOCK"] = 20] = "CAPS_LOCK";
    Keys[Keys["ESCAPE"] = 27] = "ESCAPE";
    Keys[Keys["SPACE"] = 32] = "SPACE";
    Keys[Keys["PAGE_UP"] = 33] = "PAGE_UP";
    Keys[Keys["PAGE_DOWN"] = 34] = "PAGE_DOWN";
    Keys[Keys["END"] = 35] = "END";
    Keys[Keys["HOME"] = 36] = "HOME";
    Keys[Keys["LEFT_ARROW"] = 37] = "LEFT_ARROW";
    Keys[Keys["UP_ARROW"] = 38] = "UP_ARROW";
    Keys[Keys["RIGHT_ARROW"] = 39] = "RIGHT_ARROW";
    Keys[Keys["DOWN_ARROW"] = 40] = "DOWN_ARROW";
    Keys[Keys["INSERT"] = 45] = "INSERT";
    Keys[Keys["DELETE"] = 46] = "DELETE";
    Keys[Keys["KEY_0"] = 48] = "KEY_0";
    Keys[Keys["KEY_1"] = 49] = "KEY_1";
    Keys[Keys["KEY_2"] = 50] = "KEY_2";
    Keys[Keys["KEY_3"] = 51] = "KEY_3";
    Keys[Keys["KEY_4"] = 52] = "KEY_4";
    Keys[Keys["KEY_5"] = 53] = "KEY_5";
    Keys[Keys["KEY_6"] = 54] = "KEY_6";
    Keys[Keys["KEY_7"] = 55] = "KEY_7";
    Keys[Keys["KEY_8"] = 56] = "KEY_8";
    Keys[Keys["KEY_9"] = 57] = "KEY_9";
    Keys[Keys["KEY_A"] = 65] = "KEY_A";
    Keys[Keys["KEY_B"] = 66] = "KEY_B";
    Keys[Keys["KEY_C"] = 67] = "KEY_C";
    Keys[Keys["KEY_D"] = 68] = "KEY_D";
    Keys[Keys["KEY_E"] = 69] = "KEY_E";
    Keys[Keys["KEY_F"] = 70] = "KEY_F";
    Keys[Keys["KEY_G"] = 71] = "KEY_G";
    Keys[Keys["KEY_H"] = 72] = "KEY_H";
    Keys[Keys["KEY_I"] = 73] = "KEY_I";
    Keys[Keys["KEY_J"] = 74] = "KEY_J";
    Keys[Keys["KEY_K"] = 75] = "KEY_K";
    Keys[Keys["KEY_L"] = 76] = "KEY_L";
    Keys[Keys["KEY_M"] = 77] = "KEY_M";
    Keys[Keys["KEY_N"] = 78] = "KEY_N";
    Keys[Keys["KEY_O"] = 79] = "KEY_O";
    Keys[Keys["KEY_P"] = 80] = "KEY_P";
    Keys[Keys["KEY_Q"] = 81] = "KEY_Q";
    Keys[Keys["KEY_R"] = 82] = "KEY_R";
    Keys[Keys["KEY_S"] = 83] = "KEY_S";
    Keys[Keys["KEY_T"] = 84] = "KEY_T";
    Keys[Keys["KEY_U"] = 85] = "KEY_U";
    Keys[Keys["KEY_V"] = 86] = "KEY_V";
    Keys[Keys["KEY_W"] = 87] = "KEY_W";
    Keys[Keys["KEY_X"] = 88] = "KEY_X";
    Keys[Keys["KEY_Y"] = 89] = "KEY_Y";
    Keys[Keys["KEY_Z"] = 90] = "KEY_Z";
    Keys[Keys["LEFT_META"] = 91] = "LEFT_META";
    Keys[Keys["RIGHT_META"] = 92] = "RIGHT_META";
    Keys[Keys["SELECT"] = 93] = "SELECT";
    Keys[Keys["NUMPAD_0"] = 96] = "NUMPAD_0";
    Keys[Keys["NUMPAD_1"] = 97] = "NUMPAD_1";
    Keys[Keys["NUMPAD_2"] = 98] = "NUMPAD_2";
    Keys[Keys["NUMPAD_3"] = 99] = "NUMPAD_3";
    Keys[Keys["NUMPAD_4"] = 100] = "NUMPAD_4";
    Keys[Keys["NUMPAD_5"] = 101] = "NUMPAD_5";
    Keys[Keys["NUMPAD_6"] = 102] = "NUMPAD_6";
    Keys[Keys["NUMPAD_7"] = 103] = "NUMPAD_7";
    Keys[Keys["NUMPAD_8"] = 104] = "NUMPAD_8";
    Keys[Keys["NUMPAD_9"] = 105] = "NUMPAD_9";
    Keys[Keys["MULTIPLY"] = 106] = "MULTIPLY";
    Keys[Keys["ADD"] = 107] = "ADD";
    Keys[Keys["SUBTRACT"] = 109] = "SUBTRACT";
    Keys[Keys["DECIMAL"] = 110] = "DECIMAL";
    Keys[Keys["DIVIDE"] = 111] = "DIVIDE";
    Keys[Keys["F1"] = 112] = "F1";
    Keys[Keys["F2"] = 113] = "F2";
    Keys[Keys["F3"] = 114] = "F3";
    Keys[Keys["F4"] = 115] = "F4";
    Keys[Keys["F5"] = 116] = "F5";
    Keys[Keys["F6"] = 117] = "F6";
    Keys[Keys["F7"] = 118] = "F7";
    Keys[Keys["F8"] = 119] = "F8";
    Keys[Keys["F9"] = 120] = "F9";
    Keys[Keys["F10"] = 121] = "F10";
    Keys[Keys["F11"] = 122] = "F11";
    Keys[Keys["F12"] = 123] = "F12";
    Keys[Keys["NUM_LOCK"] = 144] = "NUM_LOCK";
    Keys[Keys["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
    Keys[Keys["SEMICOLON"] = 186] = "SEMICOLON";
    Keys[Keys["EQUALS"] = 187] = "EQUALS";
    Keys[Keys["COMMA"] = 188] = "COMMA";
    Keys[Keys["DASH"] = 189] = "DASH";
    Keys[Keys["PERIOD"] = 190] = "PERIOD";
    Keys[Keys["FORWARD_SLASH"] = 191] = "FORWARD_SLASH";
    Keys[Keys["GRAVE_ACCENT"] = 192] = "GRAVE_ACCENT";
    Keys[Keys["OPEN_BRACKET"] = 219] = "OPEN_BRACKET";
    Keys[Keys["BACK_SLASH"] = 220] = "BACK_SLASH";
    Keys[Keys["CLOSE_BRACKET"] = 221] = "CLOSE_BRACKET";
    Keys[Keys["SINGLE_QUOTE"] = 222] = "SINGLE_QUOTE";
})(Keys || (Keys = {}));

function Image$1(_a) {
    var { sourceSet, source } = _a,
        rest = __rest(_a, ["sourceSet", "source"]);
    const finalSourceSet = sourceSet ? sourceSet.map(({ source: subSource, descriptor }) => `${subSource} ${descriptor}`).join(',') : null;
    return finalSourceSet ? createElement("img", Object.assign({ src: source, srcSet: finalSourceSet }, rest)) : createElement("img", Object.assign({ src: source }, rest));
}

var styles = {
  "Avatar": "p_x3",
  "sizeSmall": "p_jv",
  "sizeMedium": "p_lb",
  "sizeLarge": "p_kt",
  "styleOne": "p_r1",
  "styleTwo": "p_qs",
  "styleThree": "p_pc",
  "styleFour": "p_gh",
  "styleFive": "p_ku",
  "styleSix": "p_ln",
  "hasImage": "p_jf",
  "Image": "p_wi",
  "Initials": "p_mz",
};

var avatar1 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzI0NWI0OH0uY2xzLTJ7ZmlsbDojMmRiMTY3fS5jbHMtM3tmaWxsOiNmZmZ9LmNscy00e2ZpbGw6IzhkYzk1OH0uY2xzLTV7ZmlsbDojZWJlZGYxO29wYWNpdHk6LjJ9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMCAwaDEwMHYxMDBIMHoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02OSAwdjY1LjY1bC0yLS4wMXYxOS44NWwyIC4wMlYxMDBIMFYwaDY5eiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY3IDY1LjY0djE5Ljg1bC0yNS41Ny0uMTlDMzIgODUuMjIgMjUuNiA4MS40NiAyNS42OCA3Mi4wNnMuMjUtNi43NC4yNS02Ljc0eiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTg2Ljk5IDU4SDY5VjBoMTAuOTNsNy4wNiA1OHoiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik0yNC41MyA0MC4yOWExMi4yMyAxMi4yMyAwIDAgMSAyNC40NiAwIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNNTkuNjIgNThBMTAuNjkgMTAuNjkgMCAwIDEgODEgNTh6Ii8+PC9zdmc+';

var avatar2 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzFlMjY1Y30uY2xzLTJ7ZmlsbDojNWQ2Y2MxfS5jbHMtMywuY2xzLTV7ZmlsbDojZmZmfS5jbHMtNHtmaWxsOiNmZmMwNGR9LmNscy01e3N0cm9rZTojZmZmO3N0cm9rZS1taXRlcmxpbWl0OjEwfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTS0uMDEgMGgxMDB2MTAwaC0xMDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNLS4wMSAwaDY5LjAydjEwMEgtLjAxeiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY4LjkzIDY1Ljg4bC0yNC40NC0uMTktLjA1IDYuMDljMCA1LjIyIDMuNDggOS40NyA4LjY5IDkuNTJsMTUuOC4xMnoiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik02OC45MSAxMS4zbDE5LjE3IDQ2LjI5LTE5LjE3LS4xNlYxMS4zeiIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTIzLjI1IDM2LjQzYTMuMjIgMy4yMiAwIDEgMCAwIDYuNDRtMjEuMDEtNi40NGEzLjIyIDMuMjIgMCAwIDAgMCA2LjQ0bS0xMy41NSAzLjc0YTMuMjIgMy4yMiAwIDEgMCAwIDYuNDRtMy4yMi0yNS41MWEzLjIyIDMuMjIgMCAwIDAgMCA2LjQ0Ii8+PC9zdmc+';

var avatar3 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzVkNmNjMX0uY2xzLTJ7ZmlsbDojNmRjYWNlfS5jbHMtM3tmaWxsOm5vbmU7c3Ryb2tlOiNmZmY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLXdpZHRoOjVweH0uY2xzLTR7ZmlsbDojZWJlZGYxO29wYWNpdHk6LjJ9LmNscy01e2ZpbGw6I2ZmZn08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0tLjAyIDBoMTAwdjEwMGgtMTAweiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTS4zOSAwaDY5LjAydjEwMEguMzl6Ii8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNMjQuMTggMzEuMjF2My40N0ExMC40MyAxMC40MyAwIDAgMCAzNC40IDQ1LjIxYTEwLjQzIDEwLjQzIDAgMCAwIDEwLjIyLTEwLjUzdi0zLjQ3Ii8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMjAuMTEgNDkuMDdhMTYuMjIgMTYuMjIgMCAxIDEgMCAzMi40NCIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTY5LjQ0IDE4LjgzTDkwIDcxSDY5LjQ0VjE4LjgzeiIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTU3LjU5IDcxYTYgNiAwIDAgMSAxMiAweiIvPjwvc3ZnPg==';

var avatar4 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZTBjM30uY2xzLTJ7ZmlsbDojNWQ2Y2MxfS5jbHMtM3tmaWxsOiNmZjk2N2R9LmNscy00e2ZpbGw6bm9uZTtzdHJva2U6I2ZmZjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2Utd2lkdGg6NXB4fS5jbHMtNXtmaWxsOiNlYmVkZjE7b3BhY2l0eTouMn08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0wLS4wMWgxMDB2MTAwSDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMCAwaDY5LjAydjEwMEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY5LjAyIDBsMjQuMDMgNjEuNjlINjkuMDJWMHoiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik0zMC42OSAzMS45MXYtM2MwLTQuNzggMy40Ni04LjY1IDgtOC42NXM4IDMuODcgOCA4LjY1djMiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik0xMi43NiA1Ni4wNmExMy4zNiAxMy4zNiAwIDEgMSAyNi43MiAwIi8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNODAgNjEuNDZsLTI5LjM0LjIzdi03LjMzYzAtNi4yOCA0LjA3LTExLjM2IDEwLjM0LTExLjQ0bDE5LS4xNHoiLz48L3N2Zz4=';

var avatar5 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzhkYzk1OH0uY2xzLTJ7ZmlsbDojMmRiMTY3fS5jbHMtM3tmaWxsOiMyNDViNDh9LmNscy00e2ZpbGw6I2ViZWRmMTtvcGFjaXR5Oi4yfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTAgMGg3MC4wMnYxMDBIMHoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02OS45MiAwdjU2LjMyTDQ5IDY3bC0uMyAyNS4wN1YxMDBIMTAwVjB6Ii8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNNTkuMjcgNTguMjlhNS4yMiA1LjIyIDAgMCAwLTkuNDMgNC40OCIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTI3LjEyIDkuMzNoNDQuNTN2Mi4xOUgyNy4xMnptLTEyLjQxIDkuNDloNTYuOTR2Mi4xOUgxNC43MXoiLz48Y2lyY2xlIGNsYXNzPSJjbHMtNCIgY3g9IjE5LjY2IiBjeT0iNDQuOCIgcj0iMTEuMjIiLz48L3N2Zz4=';

var avatar6 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZTBjM30uY2xzLTJ7ZmlsbDojZmY5NjdkfS5jbHMtM3tmaWxsOiMzMmNhYzZ9LmNscy00e2ZpbGw6IzAwOTc5Nn0uY2xzLTUsLmNscy02e2ZpbGw6bm9uZTtzdHJva2U6I2ZmZjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMH0uY2xzLTV7c3Ryb2tlLXdpZHRoOjVweH0uY2xzLTZ7c3Ryb2tlLXdpZHRoOjRweH08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0tLjAyLS4wMWgxMDB2MTAwaC0xMDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMCAwaDY5LjQxdjEwMEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTY5LjkyIDB2NDQuMzJMNTEuMzQgNTV2NDVIMTAwVjB6Ii8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNMzkuMzIgNzZhMTEuODUgMTEuODUgMCAwIDAgMTIgMTEuNjJWNzYiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik0zOS4zMiA3NmExMiAxMiAwIDAgMSAxMi0xMS44MlY3NiIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTQzLjc0IDE5LjgzYTEyLjgyIDEyLjgyIDAgMSAxLTI1LjY0IDAiLz48cGF0aCBjbGFzcz0iY2xzLTYiIGQ9Ik0yNy4zOSAzMS42bC0xLjU4IDUuOTZtOS4zNy01LjcybDIuNTUgNS40N200LjI2LTkuODVsMy41MyA0LjVtLTI1LjQzLTQuNWwtMy41MyA0LjUiLz48L3N2Zz4=';

var avatar7 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzhkYzk1OH0uY2xzLTJ7ZmlsbDojMmRiMTY3fS5jbHMtM3tmaWxsOiNmZmZ9LmNscy00e2ZpbGw6IzI0NWI0OH08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0wIDBoMTAwdjEwMC40OEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTgzIDY4djMybC0xNC0uMTZ2LjE2SDBWMGg2OXY2OGgxNHoiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik02OS4yOSA0MS42OUgyMC42NnMtLjA5LTMtLjE3IDcuMTUgNyAxOC41MSAxNy4zNSAxOC41OWwzMS40NS41N3oiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik02OC43IDEyLjRsMTEuNTQgMjkuMjlINjguN1YxMi40eiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTYyLjIyIDQxLjY5YTMuMzQgMy4zNCAwIDEgMSA2LjY5IDB6Ii8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNNDEuNDUgMTguMDZhMi41NyAyLjU3IDAgMCAwLTUuMTQgME0zMy4zMyAyNGEyLjU3IDIuNTcgMCAxIDAtNS4xNCAwbTIwLjM2IDIuNThhMi41NyAyLjU3IDAgMSAwLTUuMTQgMCIvPjwvc3ZnPg==';

var avatar8 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZWRiOX0uY2xzLTJ7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS13aWR0aDo1cHh9LmNscy0ze2ZpbGw6I2ZmYzA0ZH0uY2xzLTR7ZmlsbDojNWQ2Y2MxfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNjQuNjMgMTcuMzNhMTcgMTcgMCAwIDEgNSAyOS43MiAxNi43NSAxNi43NSAwIDAgMS01IDIuNjIiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0wIDBoNjkuMDJ2MTAwSDB6Ii8+PGNpcmNsZSBjbGFzcz0iY2xzLTIiIGN4PSI0NS4xMSIgY3k9IjMzLjQ5IiByPSIxNi45OCIgdHJhbnNmb3JtPSJyb3RhdGUoLTM3LjAyIDQ1LjEyNCAzMy40OTMpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNNjkuMDIgMzQuNDhsMTkuNDcgMzguNzQtMTkuNDcgMS41M1YzNC40OHoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02MS42IDMzLjY3YTEwLjE3IDEwLjE3IDAgMCAxIDE1LjQuMDgiLz48L3N2Zz4=';

var avatar9 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmYzA0ZH0uY2xzLTJ7ZmlsbDojNWQ2Y2MxfS5jbHMtM3tmaWxsOiM0MTIzNmV9LmNscy00e2ZpbGw6I2ViZWRmMTtvcGFjaXR5Oi4yfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMCAwaDY5LjQxdjEwMEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTcwLjIxIDgwLjg4aC0xNS4xYy00LjgxIDAtNS42OC01Ljg0LTUuNjgtNS44NGgyMC43OCIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTgyIDYwLjQ4bC0xNCAuMjVWMGgxMC4xN0M4MC41OSAyMC4xNCA4MiA2MC40OCA4MiA2MC40OHoiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik01Ny43MSA2MC40OGE1LjQ0IDUuNDQgMCAxIDEgMTAuODcgMCIvPjxjaXJjbGUgY2xhc3M9ImNscy00IiBjeD0iMjQuNzciIGN5PSI0MC4xOSIgcj0iMTEuMjIiLz48L3N2Zz4=';



var avatars = Object.freeze({
	avatarOne: avatar1,
	avatarTwo: avatar2,
	avatarThree: avatar3,
	avatarFour: avatar4,
	avatarFive: avatar5,
	avatarSix: avatar6,
	avatarSeven: avatar7,
	avatarEight: avatar8,
	avatarNine: avatar9
});

const STYLE_CLASSES = ['one', 'two', 'three', 'four', 'five', 'six'];
const AVATAR_IMAGES = Object.keys(avatars).map(key => avatars[key]);
function Avatar$1({ name, source, initials, customer, size = 'medium', accessibilityLabel }) {
    const nameString = name || initials;
    let finalSource;
    let label;
    if (accessibilityLabel) {
        label = accessibilityLabel;
    } else if (name) {
        label = name;
    } else if (initials) {
        label = `Avatar with initials ${initials.split('').join(' ')}`;
    } else {
        label = 'Avatar';
    }
    if (source) {
        finalSource = source;
    } else if (customer) {
        finalSource = customerPlaceholder(nameString);
    }
    const className = classNames(styles.Avatar, styles[variationName('style', styleClass(nameString))], source && styles.hasImage, size && styles[variationName('size', size)]);
    let content = null;
    if (finalSource) {
        content = createElement(Image$1, { className: styles.Image, source: finalSource, alt: '', role: 'presentation' });
    } else if (initials) {
        content = createElement(
            'span',
            { 'aria-hidden': true, className: styles.Initials },
            initials
        );
    }
    return createElement(
        'span',
        { 'aria-label': label, role: 'img', className: className },
        content
    );
}
function styleClass(name) {
    return name ? STYLE_CLASSES[name.charCodeAt(0) % STYLE_CLASSES.length] : STYLE_CLASSES[0];
}
function customerPlaceholder(name) {
    return name ? AVATAR_IMAGES[name.charCodeAt(0) % AVATAR_IMAGES.length] : AVATAR_IMAGES[0];
}

function handleMouseUpByBlurring({ currentTarget }) {
    currentTarget.blur();
}

const scrollable = {
    props: { 'data-polaris-scrollable': true },
    selector: '[data-polaris-scrollable]'
};
const overlay = {
    props: { 'data-polaris-overlay': true },
    selector: '[data-polaris-overlay]'
};
const layer = {
    props: { 'data-polaris-layer': true },
    selector: '[data-polaris-layer]'
};
const unstyled = {
    props: { 'data-polaris-unstyled': true },
    selector: '[data-polaris-unstyled]'
};

let LinkComponent;
class UnstyledLink$1 extends PureComponent {
    static use(NewLinkComponent) {
        LinkComponent = NewLinkComponent;
    }
    render() {
        if (LinkComponent) {
            return createElement(LinkComponent, Object.assign({}, unstyled.props, this.props));
        }
        const _a = this.props,
              { external, url } = _a,
              rest = __rest(_a, ["external", "url"]);
        const target = external ? '_blank' : undefined;
        const rel = external ? 'noopener noreferrer' : undefined;
        return createElement('a', Object.assign({ target: target }, rest, { href: url, rel: rel }, unstyled.props));
    }
}

var add = {"viewBox":"0 0 20 20","body":"<path d=\"M17 9h-6V3a1 1 0 1 0-2 0v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2\"  fill-rule=\"evenodd\"/>"};

var alert = {"viewBox":"0 0 20 20","body":"<path d=\"M10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm-1-8h2V6H9v4zm0 4h2v-2H9v2z\"  fill-rule=\"evenodd\"/>"};

var arrowDown = {"viewBox":"0 0 20 20","body":"<path d=\"M10.707 17.707l5-5a.999.999 0 1 0-1.414-1.414L11 14.586V3a1 1 0 1 0-2 0v11.586l-3.293-3.293a.999.999 0 1 0-1.414 1.414l5 5a.999.999 0 0 0 1.414 0\"  fill-rule=\"evenodd\"/>"};

var arrowLeft = {"viewBox":"0 0 20 20","body":"<path d=\"M17 9H5.414l3.293-3.293a.999.999 0 1 0-1.414-1.414l-5 5a.999.999 0 0 0 0 1.414l5 5a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414L5.414 11H17a1 1 0 1 0 0-2\"  fill-rule=\"evenodd\"/>"};

var arrowRight = {"viewBox":"0 0 20 20","body":"<path d=\"M17.707 9.293l-5-5a.999.999 0 1 0-1.414 1.414L14.586 9H3a1 1 0 1 0 0 2h11.586l-3.293 3.293a.999.999 0 1 0 1.414 1.414l5-5a.999.999 0 0 0 0-1.414\"  fill-rule=\"evenodd\"/>"};

var arrowUp = {"viewBox":"0 0 20 20","body":"<path d=\"M11 17V5.414l3.293 3.293a.999.999 0 1 0 1.414-1.414l-5-5a.999.999 0 0 0-1.414 0l-5 5a.997.997 0 0 0 0 1.414.999.999 0 0 0 1.414 0L9 5.414V17a1 1 0 1 0 2 0\"  fill-rule=\"evenodd\"/>"};

var arrowUpDown = {"viewBox":"0 0 20 20","body":"<path d=\"M13 8l-3-3-3 3h6zm-.1 4L10 14.9 7.1 12h5.8z\"  fill-rule=\"evenodd\"/>"};

var calendar = {"viewBox":"0 0 20 20","body":"<path d=\"M4 8h12V6H4v2zm9 4h2v-2h-2v2zm-4 0h2v-2H9v2zm0 4h2v-2H9v2zm-4-4h2v-2H5v2zm0 4h2v-2H5v2zM17 4h-2V3a1 1 0 1 0-2 0v1H7V3a1 1 0 1 0-2 0v1H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z\"  fill-rule=\"evenodd\"/>"};

var cancel = {"viewBox":"0 0 20 20","body":"<path d=\"M11.414 10l6.293-6.293a.999.999 0 1 0-1.414-1.414L10 8.586 3.707 2.293a.999.999 0 1 0-1.414 1.414L8.586 10l-6.293 6.293a.999.999 0 1 0 1.414 1.414L10 11.414l6.293 6.293a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414L11.414 10z\"  fill-rule=\"evenodd\"/>"};

var cancelSmall = {"viewBox":"0 0 20 20","body":"<path d=\"M11.414 10l4.293-4.293a.999.999 0 1 0-1.414-1.414L10 8.586 5.707 4.293a.999.999 0 1 0-1.414 1.414L8.586 10l-4.293 4.293a.999.999 0 1 0 1.414 1.414L10 11.414l4.293 4.293a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414L11.414 10z\"  fill-rule=\"evenodd\"/>"};

var caretDown = {"viewBox":"0 0 20 20","body":"<path d=\"M5 8l5 5 5-5z\"  fill-rule=\"evenodd\"/>"};

var caretUp = {"viewBox":"0 0 20 20","body":"<path d=\"M15 12l-5-5-5 5z\" />"};

var chevronDown = {"viewBox":"0 0 20 20","body":"<path d=\"M10 14a.997.997 0 0 1-.707-.293l-5-5a.999.999 0 1 1 1.414-1.414L10 11.586l4.293-4.293a.999.999 0 1 1 1.414 1.414l-5 5A.997.997 0 0 1 10 14\"  fill-rule=\"evenodd\"/>"};

var chevronLeft = {"viewBox":"0 0 20 20","body":"<path d=\"M12 16a.997.997 0 0 1-.707-.293l-5-5a.999.999 0 0 1 0-1.414l5-5a.999.999 0 1 1 1.414 1.414L8.414 10l4.293 4.293A.999.999 0 0 1 12 16\"  fill-rule=\"evenodd\"/>"};

var chevronRight = {"viewBox":"0 0 20 20","body":"<path d=\"M8 16a.999.999 0 0 1-.707-1.707L11.586 10 7.293 5.707a.999.999 0 1 1 1.414-1.414l5 5a.999.999 0 0 1 0 1.414l-5 5A.997.997 0 0 1 8 16\"  fill-rule=\"evenodd\"/>"};

var chevronUp = {"viewBox":"0 0 20 20","body":"<path d=\"M15 13a.997.997 0 0 1-.707-.293L10 8.414l-4.293 4.293a.999.999 0 1 1-1.414-1.414l5-5a.999.999 0 0 1 1.414 0l5 5A.999.999 0 0 1 15 13\"  fill-rule=\"evenodd\"/>"};

var circleCancel = {"viewBox":"0 0 20 20","body":"<path d=\"M14.242 12.829l-1.414 1.414L10 11.413l-2.828 2.83-1.414-1.414 2.828-2.83-2.828-2.827 1.414-1.414L10 8.586l2.828-2.828 1.414 1.414L11.414 10l2.828 2.829zM10 1.999A8 8 0 1 0 10 18a8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronDown = {"viewBox":"0 0 20 20","body":"<path d=\"M10 13.414L5.293 8.707l1.414-1.414L10 10.586l3.293-3.293 1.414 1.414L10 13.414zM10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronLeft = {"viewBox":"0 0 20 20","body":"<path d=\"M11.293 5.293l1.414 1.414L9.414 10l3.293 3.293-1.414 1.414L6.586 10l4.707-4.707zM10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronRight = {"viewBox":"0 0 20 20","body":"<path d=\"M8.707 14.707l-1.414-1.414L10.586 10 7.293 6.707l1.414-1.414L13.414 10l-4.707 4.707zM10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronUp = {"viewBox":"0 0 20 20","body":"<path d=\"M14.707 11.293l-1.414 1.414L10 9.414l-3.293 3.293-1.414-1.414L10 6.586l4.707 4.707zM18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0z\"  fill-rule=\"evenodd\"/>"};

var circlePlus = {"viewBox":"0 0 20 20","body":"<path d=\"M15 11h-4v4H9v-4H5V9h4V5h2v4h4v2zm-5-9a8 8 0 1 0 0 16 8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var conversation = {"viewBox":"0 0 20 20","body":"<path d=\"M13 11h2V9h-2v2zm-4 0h2V9H9v2zm-4 0h2V9H5v2zm5-9c-4.411 0-8 3.589-8 8 0 1.504.425 2.908 1.15 4.111l-1.069 2.495a1 1 0 0 0 1.314 1.313l2.494-1.069A7.939 7.939 0 0 0 10 18c4.411 0 8-3.589 8-8s-3.589-8-8-8z\"  fill-rule=\"evenodd\"/>"};

var deleteIcon = {"viewBox":"0 0 20 20","body":"<path d=\"M16 6H4a1 1 0 1 0 0 2h1v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V8h1a1 1 0 1 0 0-2zM9 4a1 1 0 1 1 0-2h2a1 1 0 1 1 0 2H9zm2 12h2V8h-2v8zm-4 0h2V8H7v8z\"  fill-rule=\"evenodd\"/>"};

var disable = {"viewBox":"0 0 20 20","body":"<path d=\"M10 16a5.961 5.961 0 0 1-3.471-1.115l8.356-8.356A5.961 5.961 0 0 1 16 10c0 3.309-2.691 6-6 6m0-12c1.294 0 2.49.416 3.471 1.115l-8.356 8.356A5.961 5.961 0 0 1 4 10c0-3.309 2.691-6 6-6m0-2c-4.411 0-8 3.589-8 8s3.589 8 8 8 8-3.589 8-8-3.589-8-8-8\"  fill-rule=\"evenodd\"/>"};

var dispute = {"viewBox":"0 0 20 20","body":"<path d=\"M9 10h2V6H9v4zm0 4h2v-2H9v2zm-7-4c0 4.411 3.589 8 8 8a7.939 7.939 0 0 0 4.111-1.15l2.494 1.069a1 1 0 0 0 1.314-1.313l-1.069-2.495A7.939 7.939 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8z\"  fill-rule=\"evenodd\"/>"};

var duplicate = {"viewBox":"0 0 20 20","body":"<path d=\"M8 12h8V4H8v8zm4 4H4V8h2v5a1 1 0 0 0 1 1h5v2zm5-14H7a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-3h3a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z\"  fill-rule=\"evenodd\"/>"};

var embed = {"viewBox":"0 0 20 20","body":"<path d=\"M17 13a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-3a1 1 0 1 1 2 0v2h12v-2a1 1 0 0 1 1-1zm0-11a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0V4H4v2a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1h14zm.555 7.168a1.001 1.001 0 0 1 0 1.664l-3 2a1 1 0 0 1-1.109-1.664L15.198 10l-1.752-1.168a1 1 0 1 1 1.109-1.664l3 2zM6.832 7.445a1 1 0 0 1-.277 1.387L4.803 10l1.752 1.168a1 1 0 1 1-1.11 1.664l-3-2a1.001 1.001 0 0 1 0-1.664l3-2a1 1 0 0 1 1.387.277zM9 14.001a1 1 0 0 1-.948-1.317l2-6a1 1 0 0 1 1.896.633l-2 6A.999.999 0 0 1 9 14z\"  fill-rule=\"evenodd\"/>"};

var exportIcon = {"viewBox":"0 0 20 20","body":"<path d=\"M12.293 13.293a.999.999 0 1 1 1.414 1.414l-3 3a.997.997 0 0 1-1.414 0l-3-3a.999.999 0 1 1 1.414-1.414L9 14.586V7a1 1 0 1 1 2 0v7.586l1.293-1.293zM17 2a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1h-3a1 1 0 1 1 0-2h2V4H4v5h2a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h14z\"  fill-rule=\"evenodd\"/>"};

var external = {"viewBox":"0 0 20 20","body":"<path d=\"M17 2a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V5.414l-7.293 7.293a.997.997 0 0 1-1.414 0 .999.999 0 0 1 0-1.414L14.586 4H13a1 1 0 1 1 0-2h4zm-4 9a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2H4v8h8v-4a1 1 0 0 1 1-1z\"  fill-rule=\"evenodd\"/>"};

var horizontalDots = {"viewBox":"0 0 20 20","body":"<path d=\"M6 10a2 2 0 1 1-4.001-.001A2 2 0 0 1 6 10zm6 0a2 2 0 1 1-4.001-.001A2 2 0 0 1 12 10zm6 0a2 2 0 1 1-4.001-.001A2 2 0 0 1 18 10z\"  fill-rule=\"evenodd\"/>"};

var importIcon = {"viewBox":"0 0 20 20","body":"<path d=\"M13.707 10.707a.997.997 0 0 1-1.414 0L11 9.414V17a1 1 0 1 1-2 0V9.414l-1.293 1.293a.999.999 0 1 1-1.414-1.414l3-3a.999.999 0 0 1 1.414 0l3 3a.999.999 0 0 1 0 1.414zM17 2a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1h-3a1 1 0 1 1 0-2h2V4H4v9h2a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h14z\"  fill-rule=\"evenodd\"/>"};

var notes = {"viewBox":"0 0 20 20","body":"<path d=\"M6 11h8V9H6v2zm0 4h8v-2H6v2zm0-8h4V5H6v2zm9.707-1.707l-3-3A.996.996 0 0 0 12 2H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V6a.997.997 0 0 0-.293-.707z\"  fill-rule=\"evenodd\"/>"};

var print = {"viewBox":"0 0 20 20","body":"<path d=\"M14 11h2V9h-2v2zM7 7h6V4H7v3zm0 9h6v-2H7v2zm10-9h-2V3a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v4H3a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h2v1a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h2a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1z\"  fill-rule=\"evenodd\"/>"};

var refresh = {"viewBox":"0 0 20 20","body":"<path d=\"M17 11a1 1 0 0 1 1 1c0 1.654-1.346 3-3 3H5.414l1.293 1.293a.999.999 0 1 1-1.414 1.414l-3-3a.999.999 0 0 1 0-1.414l3-3a.999.999 0 1 1 1.414 1.414L5.414 13H15c.552 0 1-.449 1-1a1 1 0 0 1 1-1zM3 9a1 1 0 0 1-1-1c0-1.654 1.346-3 3-3h9.586l-1.293-1.293a.999.999 0 1 1 1.414-1.414l3 3a.999.999 0 0 1 0 1.414l-3 3a.997.997 0 0 1-1.414 0 .999.999 0 0 1 0-1.414L14.586 7H5c-.552 0-1 .449-1 1a1 1 0 0 1-1 1z\"  fill-rule=\"evenodd\"/>"};

var risk = {"viewBox":"0 0 20 20","body":"<path d=\"M9 12h2V8H9v4zm0 4h2v-2H9v2zm8.895.509l-7-14c-.339-.678-1.451-.678-1.79 0l-7 14A.999.999 0 0 0 3 17.956h14a1.001 1.001 0 0 0 .895-1.447z\"  fill-rule=\"evenodd\"/>"};

var save = {"viewBox":"0 0 20 20","body":"<path d=\"M17 4h-3a1 1 0 1 0 0 2h2v10H4V4h3.586L9 5.414v5.172L7.707 9.293a1 1 0 0 0-1.414 1.414l3 3a.996.996 0 0 0 1.414 0l3-3a1 1 0 0 0-1.414-1.414L11 10.586V5a.997.997 0 0 0-.293-.707l-2-2A.994.994 0 0 0 8 2H3a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z\"/>"};

var search = {"viewBox":"0 0 20 20","body":"<path d=\"M8 12a4 4 0 1 1 0-8 4 4 0 0 1 0 8m9.707 4.293l-4.82-4.82A5.968 5.968 0 0 0 14 8 6 6 0 0 0 2 8a6 6 0 0 0 6 6 5.968 5.968 0 0 0 3.473-1.113l4.82 4.82a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414\"  fill-rule=\"evenodd\"/>"};

var view = {"viewBox":"0 0 20 20","body":"<path d=\"M10 12c-1.104 0-2-.897-2-2s.896-2 2-2c1.102 0 2 .897 2 2s-.898 2-2 2m7.928-2.372C17.837 9.399 15.611 4 10 4S2.162 9.399 2.07 9.628a1.017 1.017 0 0 0 0 .744C2.163 10.601 4.389 16 10 16s7.837-5.399 7.928-5.628a1.017 1.017 0 0 0 0-.744\"  fill-rule=\"evenodd\"/>"};

var styles$1 = {
  "Icon": "p_oy",
  "hasBackdrop": "p_hm",
  "colorWhite": "p_vr",
  "colorBlack": "p_rm",
  "colorSkyLighter": "p_g6",
  "colorSkyLight": "p_gx",
  "colorSky": "p_uu",
  "colorSkyDark": "p_g9",
  "colorInkLightest": "p_if",
  "colorInkLighter": "p_p4",
  "colorInkLight": "p_n9",
  "colorInk": "p_zl",
  "colorBlueLighter": "p_y7",
  "colorBlueLight": "p_om",
  "colorBlue": "p_ol",
  "colorBlueDark": "p_y2",
  "colorBlueDarker": "p_ms",
  "colorIndigoLighter": "p_v2",
  "colorIndigoLight": "p_se",
  "colorIndigo": "p_j4",
  "colorIndigoDark": "p_ky",
  "colorIndigoDarker": "p_tn",
  "colorTealLighter": "p_n3",
  "colorTealLight": "p_nh",
  "colorTeal": "p_hg",
  "colorTealDark": "p_u8",
  "colorTealDarker": "p_xp",
  "colorGreenLighter": "p_j0",
  "colorGreen": "p_vo",
  "colorGreenDark": "p_me",
  "colorYellowLighter": "p_gd",
  "colorYellow": "p_de",
  "colorYellowDark": "p_lw",
  "colorOrange": "p_ft",
  "colorOrangeDark": "p_b3",
  "colorRedLighter": "p_oh",
  "colorRed": "p_x5",
  "colorRedDark": "p_t8",
  "colorPurple": "p_tp",
  "Svg": "p_n2",
  "Placeholder": "p_iz",
};

const BUNDLED_ICONS = {
    add,
    alert,
    arrowDown,
    arrowLeft,
    arrowRight,
    arrowUp,
    arrowUpDown,
    calendar,
    cancel,
    cancelSmall,
    caretDown,
    caretUp,
    chevronDown,
    chevronLeft,
    chevronRight,
    chevronUp,
    circleCancel,
    circleChevronDown,
    circleChevronLeft,
    circleChevronRight,
    circleChevronUp,
    circlePlus,
    conversation,
    delete: deleteIcon,
    disable,
    dispute,
    duplicate,
    embed,
    export: exportIcon,
    external,
    horizontalDots,
    import: importIcon,
    notes,
    print,
    refresh,
    risk,
    save,
    search,
    view
};
const COLORS_WITH_BACKDROPS = ['teal', 'tealDark', 'greenDark', 'redDark', 'yellowDark', 'ink', 'inkLighter'];
function Icon$1({ source, color, backdrop, accessibilityLabel }) {
    if (color && backdrop && COLORS_WITH_BACKDROPS.indexOf(color) < 0) {
        // tslint:disable-next-line no-console
        console.warn(`The ${color} icon doesn't accept backdrops. The icon colors that have backdrops are: ${COLORS_WITH_BACKDROPS.join(', ')}`);
    }
    const className = classNames(styles$1.Icon, color && styles$1[variationName('color', color)], backdrop && styles$1.hasBackdrop);
    let contentMarkup;
    if (source === 'placeholder') {
        contentMarkup = createElement('div', { className: styles$1.Placeholder });
    } else {
        const iconSource = typeof source === 'string' ? BUNDLED_ICONS[source] : source;
        contentMarkup = createElement('svg', { className: styles$1.Svg, viewBox: iconSource.viewBox, dangerouslySetInnerHTML: { __html: iconSource.body } });
    }
    return createElement(
        'span',
        { className: className, 'aria-label': accessibilityLabel },
        contentMarkup
    );
}

var styles$2 = {
  "Button": "p_f7",
  "disabled": "p_sj",
  "primary": "p_yd",
  "destructive": "p_b7",
  "outline": "p_m6",
  "plain": "p_ir",
  "Content": "p_e3",
  "sizeSlim": "p_k1",
  "sizeLarge": "p_mk",
  "iconOnly": "p_rv",
  "fullWidth": "p_lx",
  "Icon": "p_la",
};

function Button$1({ url, disabled, children, accessibilityLabel, onClick, onFocus, onBlur, external, icon, primary, outline, destructive, disclosure, plain, submit, size, fullWidth }) {
    const className = classNames$1(styles$2.Button, primary && styles$2.primary, outline && styles$2.outline, destructive && styles$2.destructive, disabled && styles$2.disabled, plain && styles$2.plain, size && styles$2[variationName$1('size', size)], fullWidth && styles$2.fullWidth, icon && children == null && styles$2.iconOnly);
    const disclosureIconMarkup = disclosure ? createElement(
        'span',
        { className: styles$2.Icon },
        createElement(Icon$1, { source: 'caretDown' })
    ) : null;
    const iconMarkup = icon ? createElement(
        'span',
        { className: styles$2.Icon },
        createElement(Icon$1, { source: icon })
    ) : null;
    const childMarkup = children ? createElement(
        'span',
        null,
        children
    ) : null;
    const content = iconMarkup || disclosureIconMarkup ? createElement(
        'span',
        { className: styles$2.Content },
        iconMarkup,
        childMarkup,
        disclosureIconMarkup
    ) : createElement(
        'span',
        { className: styles$2.Content },
        childMarkup
    );
    const type = submit ? 'submit' : 'button';
    return url ? createElement(
        UnstyledLink$1,
        { url: url, external: external, onClick: onClick, onFocus: onFocus, onBlur: onBlur, onMouseUp: handleMouseUpByBlurring, className: className, disabled: disabled, 'aria-label': accessibilityLabel },
        content
    ) : createElement(
        'button',
        { type: type, onClick: onClick, onFocus: onFocus, onBlur: onBlur, onMouseUp: handleMouseUpByBlurring, className: className, disabled: disabled, 'aria-label': accessibilityLabel },
        content
    );
}
function buttonsFrom(actions, overrides = {}) {
    if (actions.length != null) {
        return actions.map((action, index) => buttonFrom(action, overrides, index));
    } else {
        return buttonFrom(actions, overrides);
    }
}
function buttonFrom(_a, overrides, key) {
    var { content, onAction } = _a,
        action = __rest(_a, ["content", "onAction"]);
    return createElement(Button$1, Object.assign({ key: key, children: content, onClick: onAction }, action, overrides));
}

var styles$3 = {
  "ButtonGroup": "p_hs",
  "segmented": "p_a4",
  "Item": "p_b9",
  "Item-focused": "p_p8",
  "Item-plain": "p_nt",
};

class Item extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = { focused: false };
    }
    render() {
        const { button } = this.props;
        const { focused } = this.state;
        const className = classNames(styles$3.Item, focused && styles$3['Item-focused'], button.props.plain && styles$3['Item-plain']);
        return createElement(
            'div',
            { className: className, onFocus: this.handleFocus, onBlur: this.handleBlur },
            button
        );
    }
    handleFocus() {
        this.setState({ focused: true });
    }
    handleBlur() {
        this.setState({ focused: false });
    }
}
__decorate([autobind], Item.prototype, "handleFocus", null);
__decorate([autobind], Item.prototype, "handleBlur", null);

function ButtonGroup$1({ children, segmented }) {
    const className = classNames(styles$3.ButtonGroup, segmented && styles$3.segmented);
    const contents = elementChildren(children).map((child, index) => createElement(Item, { button: child, key: index }));
    return createElement(
        'div',
        { className: className },
        contents
    );
}

var styles$4 = {
  "Stack": "p_wq",
  "Item": "p_gl",
  "vertical": "p_y9",
  "spacingNone": "p_qi",
  "spacingExtraTight": "p_p7",
  "spacingTight": "p_ck",
  "spacingLoose": "p_mj",
  "spacingExtraLoose": "p_uh",
  "distributionLeading": "p_v7",
  "distributionTrailing": "p_ab",
  "distributionCenter": "p_ag",
  "distributionEqualSpacing": "p_ew",
  "distributionFill": "p_s1",
  "distributionFillEvenly": "p_g5",
  "alignmentLeading": "p_bh",
  "alignmentTrailing": "p_bq",
  "alignmentCenter": "p_hr",
  "alignmentFill": "p_m4",
  "alignmentBaseline": "p_rp",
  "Item-fill": "p_g7",
};

function Item$1({ children, fill }) {
    const className = classNames(styles$4.Item, fill && styles$4['Item-fill']);
    return createElement(
        'div',
        { className: className },
        children
    );
}

class Stack$1 extends PureComponent {
    render() {
        const { children, vertical, spacing, distribution, alignment } = this.props;
        const className = classNames(styles$4.Stack, vertical && styles$4.vertical, spacing && styles$4[variationName('spacing', spacing)], distribution && styles$4[variationName('distribution', distribution)], alignment && styles$4[variationName('alignment', alignment)]);
        const itemMarkup = elementChildren(children).map((child, index) => wrapWithComponent(child, Item$1, { key: index }));
        return createElement(
            'div',
            { className: className },
            itemMarkup
        );
    }
}
Stack$1.Item = Item$1;

var styles$5 = {
  "Heading": "p_th",
};

function Heading$1({ element: Element = 'h2', children }) {
    return createElement(
        Element,
        { className: styles$5.Heading },
        children
    );
}

var styles$6 = {
  "Card": "p_rs",
  "subdued": "p_bi",
  "Header": "p_i9",
  "Section": "p_xh",
  "Section-subdued": "p_fh",
  "SectionHeader": "p_nf",
  "Footer": "p_iw",
};

function Header({ children, actions }) {
  const actionMarkup = actions ? createElement(
    ButtonGroup$1,
    null,
    buttonsFrom(actions, { plain: true })
  ) : null;
  const headingMarkup = actionMarkup ? createElement(
    Stack$1,
    { alignment: 'baseline' },
    createElement(
      Stack$1.Item,
      { fill: true },
      createElement(
        Heading$1,
        null,
        children
      )
    ),
    actionMarkup
  ) : createElement(
    Heading$1,
    null,
    children
  );
  return createElement(
    'div',
    { className: styles$6.Header },
    headingMarkup
  );
}

var styles$7 = {
  "Subheading": "p_ja",
};

function Subheading$1({ element: Element = 'h3', children }) {
    const ariaLabel = typeof children === 'string' ? children : null;
    return createElement(
        Element,
        { 'aria-label': ariaLabel, className: styles$7.Subheading },
        children
    );
}

function Section({ children, title, subdued }) {
    const headerContent = title ? createElement(
        'div',
        { className: styles$6.SectionHeader },
        createElement(
            Subheading$1,
            null,
            title
        )
    ) : null;
    const className = classNames(styles$6.Section, subdued && styles$6['Section-subdued']);
    return createElement(
        'div',
        { className: className },
        headerContent,
        children
    );
}

class Card$1 extends PureComponent {
    render() {
        const { children, title, subdued, sectioned, actions, primaryFooterAction, secondaryFooterAction } = this.props;
        const className = classNames(styles$6.Card, subdued && styles$6.subdued);
        const headerMarkup = title ? createElement(
            Header,
            { actions: actions },
            title
        ) : null;
        const content = sectioned ? createElement(
            Section,
            null,
            children
        ) : children;
        const primaryFooterActionMarkup = primaryFooterAction ? buttonFrom(primaryFooterAction, { primary: true }) : null;
        const secondaryFooterActionMarkup = secondaryFooterAction ? buttonFrom(secondaryFooterAction) : null;
        const footerMarkup = primaryFooterActionMarkup || secondaryFooterActionMarkup ? createElement(
            'div',
            { className: styles$6.Footer },
            createElement(
                ButtonGroup$1,
                null,
                primaryFooterActionMarkup,
                secondaryFooterActionMarkup
            )
        ) : null;
        return createElement(
            'div',
            { className: className },
            headerMarkup,
            content,
            footerMarkup
        );
    }
}
Card$1.Section = Section;

var styles$8 = {
  "SettingAction": "p_ae",
  "Setting": "p_gm",
  "Action": "p_kh",
};

function SettingAction$1({ action, children }) {
  return createElement(
    'div',
    { className: styles$8.SettingAction },
    createElement(
      'div',
      { className: styles$8.Setting },
      children
    ),
    createElement(
      'div',
      { className: styles$8.Action },
      action
    )
  );
}

var styles$9 = {
  "variationPositive": "p_ts",
  "variationNegative": "p_eh",
  "variationStrong": "p_v4",
  "variationSubdued": "p_sx",
};

function TextStyle$1({ variation, children }) {
    const className = classNames(variation && styles$9[variationName('variation', variation)]);
    return createElement(
        'span',
        { className: className },
        children
    );
}

var styles$10 = {
  "TermsOfService": "p_uk",
  "Content": "p_aa",
};

function AccountConnection$1({ connected = false, action, avatarUrl, accountName = '', title, details, termsOfService }) {
    const initials = accountName ? accountName.split(/\s+/).map(name => name[0]).join('') : undefined;
    const avatarMarkup = connected ? createElement(Avatar$1, { accessibilityLabel: '', name: accountName, initials: initials, source: avatarUrl }) : null;
    let titleMarkup = null;
    if (title) {
        titleMarkup = createElement(
            'div',
            null,
            title
        );
    } else if (accountName) {
        titleMarkup = createElement(
            'div',
            null,
            accountName
        );
    }
    const detailsMarkup = details ? createElement(
        'div',
        null,
        createElement(
            TextStyle$1,
            { variation: 'subdued' },
            details
        )
    ) : null;
    const termsOfServiceMarkup = termsOfService ? createElement(
        'div',
        { className: styles$10.TermsOfService },
        termsOfService
    ) : null;
    const actionElement = action ? buttonFrom(action, { primary: !connected }) : null;
    return createElement(
        Card$1,
        { sectioned: true },
        createElement(
            SettingAction$1,
            { action: actionElement },
            createElement(
                Stack$1,
                null,
                avatarMarkup,
                createElement(
                    Stack$1.Item,
                    { fill: true },
                    createElement(
                        'div',
                        { className: styles$10.Content },
                        titleMarkup,
                        detailsMarkup
                    )
                )
            )
        ),
        termsOfServiceMarkup
    );
}

var styles$11 = {
  "ActionList": "p_q2",
  "Section-withoutTitle": "p_uj",
  "Actions": "p_gb",
  "Title": "p_ui",
  "Item": "p_zd",
  "Image": "p_c0",
  "Content": "p_s3",
  "Text": "p_hl",
};

function Item$2({ content, url, onAction, icon, image }) {
    let imageElement = null;
    if (icon) {
        imageElement = createElement(
            'div',
            { className: styles$11.Image },
            createElement(Icon$1, { source: icon })
        );
    } else if (image) {
        imageElement = createElement('div', { role: 'presentation', className: styles$11.Image, style: { backgroundImage: image } });
    }
    const contentElement = imageElement ? createElement(
        'div',
        { className: styles$11.Content },
        imageElement,
        createElement(
            'div',
            { className: styles$11.Text },
            content
        )
    ) : content;
    const control = url ? createElement(
        UnstyledLink$1,
        { url: url, className: styles$11.Item },
        contentElement
    ) : createElement(
        'button',
        { onClick: onAction, className: styles$11.Item },
        contentElement
    );
    return createElement(
        'li',
        null,
        control
    );
}

function ActionList$1({ items, sections = [] }) {
    let finalSections = [];
    if (items) {
        finalSections = [{ items }].concat(sections);
    } else if (sections) {
        finalSections = sections;
    }
    const hasMultipleSections = finalSections.length > 1;
    const Element = hasMultipleSections ? 'ul' : 'div';
    const sectionMarkup = finalSections.map((section, index) => renderSection(section, hasMultipleSections, index));
    return createElement(
        Element,
        { className: styles$11.ActionList },
        sectionMarkup
    );
}
function renderSection(section, hasMultipleSections, index) {
    const SectionElement = hasMultipleSections ? 'li' : 'div';
    const actionMarkup = section.items.map(_a => {
        var { content } = _a,
            item = __rest(_a, ["content"]);
        return createElement(Item$2, Object.assign({ key: content, content: content }, item));
    });
    const className = section.title ? null : styles$11['Section-withoutTitle'];
    const titleMarkup = section.title ? createElement(
        'p',
        { className: styles$11.Title },
        section.title
    ) : null;
    return createElement(
        SectionElement,
        { key: section.title || index, className: className },
        titleMarkup,
        createElement(
            'ul',
            { className: styles$11.Actions },
            actionMarkup
        )
    );
}

var styles$12 = {
  "VisuallyHidden": "p_xi",
};

function VisuallyHidden$1({ children }) {
    return createElement(
        'span',
        { className: styles$12.VisuallyHidden },
        children
    );
}

var styles$13 = {
  "Badge": "p_i3",
  "Pip": "p_l9",
  "statusSuccess": "p_so",
  "statusInfo": "p_id",
  "statusAttention": "p_ld",
  "statusWarning": "p_wp",
  "progressIncomplete": "p_dy",
  "progressPartiallyComplete": "p_bg",
  "progressComplete": "p_lv",
};

const PROGRESS_LABELS = {
    incomplete: 'Incomplete',
    partiallyComplete: 'Partially complete',
    complete: 'Complete'
};
const STATUS_LABELS = {
    info: 'Info',
    success: 'Success',
    warning: 'Warning',
    attention: 'Attention'
};
function Badge$1({ children, status, progress }) {
    const className = classNames(styles$13.Badge, status && styles$13[variationName('status', status)], progress && styles$13[variationName('progress', progress)]);
    const pipMarkup = progress ? createElement(
        'span',
        { className: styles$13.Pip },
        createElement(
            VisuallyHidden$1,
            null,
            PROGRESS_LABELS[progress]
        )
    ) : null;
    const statusLabelMarkup = status ? createElement(
        VisuallyHidden$1,
        null,
        STATUS_LABELS[status]
    ) : null;
    return createElement(
        'span',
        { className: className },
        statusLabelMarkup,
        pipMarkup,
        children
    );
}

var styles$14 = {
  "Banner": "p_co",
  "hasDismiss": "p_a9",
  "statusSuccess": "p_nl",
  "statusInfo": "p_nk",
  "statusWarning": "p_f6",
  "statusCritical": "p_bp",
  "Ribbon": "p_mh",
  "Heading": "p_do",
  "Actions": "p_dg",
  "Content": "p_qk",
  "SecondaryAction": "p_z3",
  "Text": "p_sb",
  "Dismiss": "p_fv",
};

var successIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle fill=\"currentColor\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m2.293-10.707L9 10.586 7.707 9.293a1 1 0 1 0-1.414 1.414l2 2a.997.997 0 0 0 1.414 0l4-4a1 1 0 1 0-1.414-1.414\" /></g>"};

var fallbackIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><path fill=\"currentColor\" d=\"M2 3h11v4h6l-2 4 2 4H8v-4H3\"/><path d=\"M16.105 11.447L17.381 14H9v-2h4a1 1 0 0 0 1-1V8h3.38l-1.274 2.552a.993.993 0 0 0 0 .895zM2.69 4H12v6H4.027L2.692 4zm15.43 7l1.774-3.553A1 1 0 0 0 19 6h-5V3c0-.554-.447-1-1-1H2.248L1.976.782a1 1 0 1 0-1.953.434l4 18a1.006 1.006 0 0 0 1.193.76 1 1 0 0 0 .76-1.194L4.47 12H7v3a1 1 0 0 0 1 1h11c.346 0 .67-.18.85-.476a.993.993 0 0 0 .044-.972l-1.775-3.553z\" /></g>"};

var warningIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle fill=\"currentColor\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-13a1 1 0 0 0-1 1v4a1 1 0 1 0 2 0V6a1 1 0 0 0-1-1m0 8a1 1 0 1 0 0 2 1 1 0 0 0 0-2\" /></g>"};

var criticalIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle fill=\"currentColor\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M2 10c0-1.846.635-3.543 1.688-4.897l11.209 11.209A7.954 7.954 0 0 1 10 18c-4.411 0-8-3.589-8-8m14.312 4.897L5.103 3.688A7.954 7.954 0 0 1 10 2c4.411 0 8 3.589 8 8a7.952 7.952 0 0 1-1.688 4.897M0 10c0 5.514 4.486 10 10 10s10-4.486 10-10S15.514 0 10 0 0 4.486 0 10\" /></g>"};

var infoIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle cx=\"10\" cy=\"10\" r=\"9\" fill=\"currentColor\"/><path  d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8m1-5v-3a1 1 0 0 0-1-1H9a1 1 0 1 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2m-1-5.9a1.1 1.1 0 1 0 0-2.2 1.1 1.1 0 0 0 0 2.2\"/></g>"};

function Banner$1({ icon, action, secondaryAction, title, children, status, onDismiss }) {
    let color;
    let defaultIcon;
    let ariaRoleType = 'status';
    switch (status) {
        case 'success':
            color = 'greenDark';
            defaultIcon = successIcon;
            break;
        case 'info':
            color = 'tealDark';
            defaultIcon = infoIcon;
            break;
        case 'warning':
            color = 'yellowDark';
            defaultIcon = warningIcon;
            ariaRoleType = 'alert';
            break;
        case 'critical':
            color = 'redDark';
            defaultIcon = criticalIcon;
            ariaRoleType = 'alert';
            break;
        default:
            color = 'inkLighter';
            defaultIcon = fallbackIcon;
    }
    const className = classNames(styles$14.Banner, status && styles$14[variationName('status', status)], onDismiss && styles$14.hasDismiss);
    const id = uniqueID();
    const iconName = icon || defaultIcon;
    let headingMarkup = null;
    let headingID;
    if (title) {
        headingID = `${id}Heading`;
        headingMarkup = createElement(
            'div',
            { className: styles$14.Heading, id: headingID },
            createElement(
                Heading$1,
                { element: 'p' },
                title
            )
        );
    }
    const secondaryActionMarkup = secondaryAction ? secondaryActionFrom(secondaryAction) : null;
    const actionMarkup = action ? createElement(
        'div',
        { className: styles$14.Actions },
        createElement(
            ButtonGroup$1,
            null,
            buttonFrom(action, { outline: true }),
            secondaryActionMarkup
        )
    ) : null;
    let contentMarkup = null;
    let contentID;
    if (children || actionMarkup) {
        contentID = `${id}Content`;
        contentMarkup = createElement(
            'div',
            { className: styles$14.Content, id: contentID },
            children,
            actionMarkup
        );
    }
    const dismissButton = onDismiss ? createElement(
        'div',
        { className: styles$14.Dismiss },
        createElement(Button$1, { plain: true, icon: 'cancelSmall', onClick: onDismiss, accessibilityLabel: 'Dismiss notification' })
    ) : null;
    return createElement(
        'div',
        { className: className, tabIndex: 0, role: ariaRoleType, 'aria-live': 'polite', onMouseUp: handleMouseUp, 'aria-labelledby': headingID, 'aria-describedby': contentID },
        dismissButton,
        createElement(
            'div',
            { className: styles$14.Ribbon },
            createElement(Icon$1, { source: iconName, color: color, backdrop: true })
        ),
        createElement(
            'div',
            null,
            headingMarkup,
            contentMarkup
        )
    );
}
let index = 1;
function uniqueID() {
    return `Banner${index++}`;
}
function handleMouseUp({ currentTarget }) {
    currentTarget.blur();
}
function secondaryActionFrom(action) {
    if (action.url) {
        return createElement(
            UnstyledLink$1,
            { className: styles$14.SecondaryAction, url: action.url },
            createElement(
                'span',
                { className: styles$14.Text },
                action.content
            )
        );
    }
    return createElement(
        'button',
        { className: styles$14.SecondaryAction, onClick: action.onAction },
        createElement(
            'span',
            { className: styles$14.Text },
            action.content
        )
    );
}

var styles$15 = {
  "TextContainer": "p_gc",
};

function TextContainer$1({ children }) {
    return createElement(
        'div',
        { className: styles$15.TextContainer },
        children
    );
}

var styles$16 = {
  "CalloutCard": "p_dp",
  "Image": "p_ko",
  "Content": "p_hc",
  "Title": "p_cf",
  "Buttons": "p_pk",
};

function CalloutCard$1({ title, children, illustration, primaryAction, secondaryAction }) {
  const primaryActionMarkup = buttonFrom(primaryAction);
  const secondaryActionMarkup = secondaryAction ? buttonFrom(secondaryAction, { plain: true }) : null;
  const buttonMarkup = secondaryActionMarkup ? createElement(
    ButtonGroup$1,
    null,
    primaryActionMarkup,
    secondaryActionMarkup
  ) : primaryActionMarkup;
  return createElement(
    Card$1,
    { sectioned: true },
    createElement(
      'div',
      { className: styles$16.CalloutCard },
      createElement(
        'div',
        { className: styles$16.Content },
        createElement(
          'div',
          { className: styles$16.Title },
          createElement(
            Heading$1,
            null,
            title
          )
        ),
        createElement(
          TextContainer$1,
          null,
          children
        ),
        createElement(
          'div',
          { className: styles$16.Buttons },
          buttonMarkup
        )
      ),
      createElement(Image$1, { alt: '', className: styles$16.Image, source: illustration })
    )
  );
}

var styles$17 = {
  "Caption": "p_ik",
};

function Caption$1({ children }) {
    return createElement(
        'p',
        { className: styles$17.Caption },
        children
    );
}

var styles$18 = {
  "Choice": "p_x1",
  "labelHidden": "p_gp",
  "Label": "p_ro",
  "Control": "p_yj",
  "Descriptions": "p_xm",
  "HelpText": "p_zq",
  "Error": "p_ds",
  "ErrorIcon": "p_l0",
};

function Choice$1({ id, label, error, children, labelHidden, helpText }) {
    const className = classNames(styles$18.Choice, labelHidden && styles$18.labelHidden);
    const labelMarkup = createElement(
        'label',
        { className: className, htmlFor: id },
        createElement(
            'span',
            { className: styles$18.Control },
            children
        ),
        createElement(
            'span',
            { className: styles$18.Label },
            label
        )
    );
    const helpTextMarkup = helpText ? createElement(
        'div',
        { className: styles$18.HelpText, id: helpTextID(id) },
        helpText
    ) : null;
    const errorMarkup = typeof error === 'string' ? createElement(
        'div',
        { className: styles$18.Error, id: errorID(id) },
        createElement(
            'div',
            { className: styles$18.ErrorIcon },
            createElement(Icon$1, { source: 'alert' })
        ),
        error
    ) : null;
    const descriptionMarkup = helpTextMarkup || errorMarkup ? createElement(
        'div',
        { className: styles$18.Descriptions },
        errorMarkup,
        helpTextMarkup
    ) : null;
    return descriptionMarkup ? createElement(
        'div',
        null,
        labelMarkup,
        descriptionMarkup
    ) : labelMarkup;
}
function helpTextID(id) {
    return `${id}HelpText`;
}
function errorID(id) {
    return `${id}Error`;
}

var checkmark = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><path d=\"M8.315 13.859l-3.182-3.417a.506.506 0 0 1 0-.684l.643-.683a.437.437 0 0 1 .642 0l2.22 2.393 4.942-5.327a.437.437 0 0 1 .643 0l.643.684a.504.504 0 0 1 0 .683l-5.91 6.35a.437.437 0 0 1-.642 0\"/><path d=\"M8.315 13.859l-3.182-3.417a.506.506 0 0 1 0-.684l.643-.683a.437.437 0 0 1 .642 0l2.22 2.393 4.942-5.327a.437.437 0 0 1 .643 0l.643.684a.504.504 0 0 1 0 .683l-5.91 6.35a.437.437 0 0 1-.642 0\"/></g>"};

var styles$19 = {
  "Checkbox": "p_re",
  "error": "p_ue",
  "Input": "p_ud",
  "Backdrop": "p_nc",
  "Icon": "p_ev",
};

const getUniqueID = createUniqueIDFactory('Checkbox');
function Checkbox$1({ id = getUniqueID(), label, labelHidden, helpText, checked, error, disabled, onChange, onFocus, onBlur, name, value }) {
    function handleChange(event) {
        if (onChange == null) {
            return;
        }
        const { currentTarget } = event;
        onChange(currentTarget.checked, id);
    }
    const describedBy = [];
    if (typeof error === 'string') {
        describedBy.push(errorID(id));
    }
    if (helpText) {
        describedBy.push(helpTextID(id));
    }
    const className = classNames(styles$19.Checkbox, error && styles$19.error);
    return createElement(
        Choice$1,
        { id: id, label: label, labelHidden: labelHidden, helpText: helpText, error: error },
        createElement(
            'div',
            { className: className },
            createElement('input', { id: id, name: name, value: value, type: 'checkbox', checked: checked, disabled: disabled, className: styles$19.Input, onChange: handleChange, onFocus: onFocus, onBlur: onBlur, 'aria-invalid': error != null, 'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined }),
            createElement('div', { className: styles$19.Backdrop }),
            createElement(
                'div',
                { className: styles$19.Icon },
                createElement(Icon$1, { source: checkmark })
            )
        )
    );
}

var styles$20 = {
  "RadioButton": "p_si",
  "Input": "p_bo",
  "Backdrop": "p_po",
  "Icon": "p_tw",
};

const getUniqueID$2 = createUniqueIDFactory('RadioButton');
function RadioButton$1({ label, labelHidden, helpText, checked, disabled, onChange, onFocus, onBlur, id = getUniqueID$2(), name = id, value }) {
    function handleChange({ currentTarget }) {
        if (onChange == null) {
            return;
        }
        onChange(currentTarget.checked, id);
    }
    const describedBy = helpText ? helpTextID(id) : null;
    return createElement(
        Choice$1,
        { label: label, labelHidden: labelHidden, id: id, helpText: helpText },
        createElement(
            'div',
            { className: styles$20.RadioButton },
            createElement('input', { id: id, name: name, value: value, type: 'radio', checked: checked, disabled: disabled, className: styles$20.Input, onChange: handleChange, onFocus: onFocus, onBlur: onBlur, 'aria-describedby': describedBy }),
            createElement('div', { className: styles$20.Backdrop }),
            createElement('div', { className: styles$20.Icon })
        )
    );
}

var styles$21 = {
  "ChoiceList": "p_h8",
  "titleHidden": "p_go",
  "Title": "p_pe",
  "Choices": "p_v6",
};

const getUniqueID$1 = createUniqueIDFactory('ChoiceList');
function ChoiceList$1({ title, titleHidden, allowMultiple, choices, selected, onChange = noop, name = getUniqueID$1() }) {
    const ControlComponent = allowMultiple ? Checkbox$1 : RadioButton$1;
    const finalName = allowMultiple ? `${name}[]` : name;
    const className = classNames(styles$21.ChoiceList, titleHidden && styles$21.titleHidden);
    const titleMarkup = title ? createElement(
        'legend',
        { className: styles$21.Title },
        title
    ) : null;
    const choicesMarkup = choices.map(choice => {
        const { value, label, helpText } = choice;
        function handleChange(checked) {
            onChange(updateSelectedChoices(choice, checked, selected, allowMultiple), name);
        }
        return createElement(
            'li',
            { key: value },
            createElement(ControlComponent, { name: finalName, value: value, label: label, checked: choiceIsSelected(choice, selected), helpText: helpText, onChange: handleChange })
        );
    });
    return createElement(
        'fieldset',
        { className: className },
        titleMarkup,
        createElement(
            'ul',
            { className: styles$21.Choices },
            choicesMarkup
        )
    );
}
function choiceIsSelected({ value }, selected) {
    return selected.indexOf(value) >= 0;
}
function updateSelectedChoices({ value }, checked, selected, allowMultiple = false) {
    if (checked) {
        return allowMultiple ? [...selected, value] : [value];
    }
    return selected.filter(selectedChoice => selectedChoice !== value);
}

var styles$22 = {
  "Collapsible": "p_xz",
  "animating": "p_jg",
  "open": "p_u3",
};

const CONTEXT_TYPES = {
    parentCollapsibleExpanding: bool
};
class Collapsible$1 extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            height: null,
            animationState: 'idle'
        };
        this.node = null;
        this.heightNode = null;
    }
    getChildContext() {
        const { open } = this.props;
        const { animationState } = this.state;
        const { parentCollapsibleExpanding } = this.context;
        return {
            parentCollapsibleExpanding: parentCollapsibleExpanding || open && animationState !== 'idle'
        };
    }
    componentWillReceiveProps({ open: willOpen }) {
        const { open } = this.props;
        if (open !== willOpen) {
            this.setState({ animationState: 'measuring' });
        }
    }
    componentDidUpdate({ open: wasOpen }) {
        const { animationState } = this.state;
        const { parentCollapsibleExpanding } = this.context;
        if (parentCollapsibleExpanding && animationState !== 'idle') {
            this.setState({
                animationState: 'idle'
            });
            return;
        }
        read(() => {
            switch (animationState) {
                case 'idle':
                    break;
                case 'measuring':
                    this.setState({
                        animationState: wasOpen ? 'closingStart' : 'openingStart',
                        height: wasOpen && this.heightNode ? this.heightNode.scrollHeight : 0
                    });
                    break;
                case 'closingStart':
                    this.setState({
                        animationState: 'closing',
                        height: 0
                    });
                    break;
                case 'openingStart':
                    this.setState({
                        animationState: 'opening',
                        height: this.heightNode ? this.heightNode.scrollHeight : 0
                    });
                    break;
            }
        });
    }
    componentDidMount() {
        if (this.node == null) {
            return;
        }
        addEventListener(this.node, 'transitionend', this.handleTransitionEnd);
    }
    componentWillUnmount() {
        if (this.node == null) {
            return;
        }
        removeEventListener(this.node, 'transitionend', this.handleTransitionEnd);
    }
    render() {
        const { children, open } = this.props;
        const { animationState, height } = this.state;
        const animating = animationState !== 'idle';
        const wrapperClassName = classNames(styles$22.Collapsible, open && styles$22.open, animating && styles$22.animating);
        const displayHeight = collapsibleHeight(open, animationState, height);
        const content = animating || open ? children : null;
        return createElement(
            'div',
            { 'aria-hidden': !open, style: { height: displayHeight }, className: wrapperClassName, ref: this.bindNode },
            createElement(
                'div',
                { ref: this.bindHeightNode },
                content
            )
        );
    }
    bindNode(node) {
        this.node = node;
    }
    bindHeightNode(node) {
        this.heightNode = node;
    }
    handleTransitionEnd(event) {
        const { target } = event;
        if (target === this.node) {
            this.setState({ animationState: 'idle', height: null });
        }
    }
}
Collapsible$1.contextTypes = CONTEXT_TYPES;
Collapsible$1.childContextTypes = CONTEXT_TYPES;
__decorate([autobind], Collapsible$1.prototype, "bindNode", null);
__decorate([autobind], Collapsible$1.prototype, "bindHeightNode", null);
__decorate([autobind], Collapsible$1.prototype, "handleTransitionEnd", null);
function collapsibleHeight(open, animationState, height) {
    if (animationState === 'idle' && open) {
        return open ? 'auto' : null;
    }
    if (animationState === 'measuring') {
        return open ? null : 'auto';
    }
    return `${height || 0}px`;
}

function rgbString(color) {
    const { red, green, blue } = color;
    if (color.hasOwnProperty('alpha')) {
        return `rgba(${red}, ${green}, ${blue}, ${color.alpha})`;
    } else {
        return `rgb(${red}, ${green}, ${blue})`;
    }
}
const rgbaString = rgbString;
function rgbToHex({ red, green, blue }) {
    return `#${componentToHex(red)}${componentToHex(green)}${componentToHex(blue)}`;
}
function componentToHex(component) {
    const hex = component.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
}
function hsbToHex(color) {
    return rgbToHex(hsbToRgb(color));
}
function hsbToRgb(color) {
    const { hue, saturation, brightness, alpha = 1 } = color;
    const chroma = brightness * saturation;
    const huePrime = hue / 60;
    const hueDelta = 1 - Math.abs(huePrime % 2 - 1);
    const intermediateValue = chroma * hueDelta;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (huePrime >= 0 && huePrime <= 1) {
        red = chroma;
        green = intermediateValue;
        blue = 0;
    }
    if (huePrime >= 1 && huePrime <= 2) {
        red = intermediateValue;
        green = chroma;
        blue = 0;
    }
    if (huePrime >= 2 && huePrime <= 3) {
        red = 0;
        green = chroma;
        blue = intermediateValue;
    }
    if (huePrime >= 3 && huePrime <= 4) {
        red = 0;
        green = intermediateValue;
        blue = chroma;
    }
    if (huePrime >= 4 && huePrime <= 5) {
        red = intermediateValue;
        green = 0;
        blue = chroma;
    }
    if (huePrime >= 5 && huePrime <= 6) {
        red = chroma;
        green = 0;
        blue = intermediateValue;
    }
    const chromaBrightnessDelta = brightness - chroma;
    red += chromaBrightnessDelta;
    green += chromaBrightnessDelta;
    blue += chromaBrightnessDelta;
    return {
        red: Math.round(red * 255),
        green: Math.round(green * 255),
        blue: Math.round(blue * 255),
        alpha
    };
}
function rgbToHsb(color) {
    const { red, green, blue, alpha = 1 } = color;
    const r = red / 255;
    const g = green / 255;
    const b = blue / 255;
    const largestComponent = Math.max(r, g, b);
    const smallestComponent = Math.min(r, g, b);
    const delta = largestComponent - smallestComponent;
    const saturation = largestComponent === 0 ? 0 : delta / largestComponent;
    let huePercentage = 0;
    switch (largestComponent) {
        case r:
            huePercentage = (g - b) / delta % 6;
            break;
        case g:
            huePercentage = (b - r) / delta + 2;
            break;
        case b:
            huePercentage = (r - g) / delta + 4;
            break;
    }
    const hue = Math.round(huePercentage / 6 * 360);
    return {
        hue: clamp(hue, 0, 360) || 0,
        saturation: clamp(saturation, 0, 1),
        brightness: clamp(largestComponent, 0, 1),
        alpha
    };
}

// see https://github.com/oliviertassinari/react-event-listener/
class EventListener$1 extends PureComponent {
    componentDidMount() {
        this.attachListener();
    }
    componentWillUpdate() {
        this.detachListener();
    }
    componentDidUpdate() {
        this.attachListener();
    }
    componentWillUnmount() {
        this.detachListener();
    }
    // tslint:disable-next-line prefer-function-over-method
    render() {
        return null;
    }
    attachListener() {
        const { event, handler, capture, passive } = this.props;
        addEventListener(window, event, handler, { capture, passive });
    }
    detachListener() {
        const { event, handler, capture } = this.props;
        removeEventListener(window, event, handler, capture);
    }
}

var styles$23 = {
  "ColorPicker": "p_uq",
  "MainColor": "p_z9",
  "Dragger": "p_vi",
  "ColorLayer": "p_h2",
  "HuePicker": "p_br",
  "AlphaPicker": "p_bk",
  "Slidable": "p_dz",
};

class Slidable extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragging: false
        };
        this.node = null;
        this.draggerNode = null;
    }
    componentDidMount() {
        const { onDraggerHeight } = this.props;
        if (onDraggerHeight == null) {
            return;
        }
        const { draggerNode } = this;
        if (draggerNode == null) {
            return;
        }
        onDraggerHeight(draggerNode.clientWidth);
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                onDraggerHeight(draggerNode.clientWidth);
            }, 0);
        }
    }
    render() {
        const { dragging } = this.state;
        const { draggerX = 0, draggerY = 0 } = this.props;
        const draggerPositioning = {
            transform: `translate3d(${draggerX}px, ${draggerY}px, 0)`
        };
        const moveListener = dragging ? createElement(EventListener$1, { event: 'mousemove', handler: this.handleMove }) : null;
        const touchMoveListener = dragging ? createElement(EventListener$1, { event: 'touchmove', handler: this.handleMove }) : null;
        const endDragListener = dragging ? createElement(EventListener$1, { event: 'mouseup', handler: this.handleDragEnd }) : null;
        const touchEndListener = dragging ? createElement(EventListener$1, { event: 'touchend', handler: this.handleDragEnd }) : null;
        const touchCancelListener = dragging ? createElement(EventListener$1, { event: 'touchcancel', handler: this.handleDragEnd }) : null;
        return createElement(
            'div',
            { ref: this.setNode, className: styles$23.Slidable, onMouseDown: this.startDrag, onTouchStart: this.startDrag },
            endDragListener,
            moveListener,
            touchMoveListener,
            touchEndListener,
            touchCancelListener,
            createElement('div', { style: draggerPositioning, className: styles$23.Dragger, ref: this.setDraggerNode })
        );
    }
    setDraggerNode(node) {
        this.draggerNode = node;
    }
    setNode(node) {
        this.node = node;
    }
    startDrag(event) {
        if (event.type === 'mousedown') {
            const mouseEvent = event;
            this.handleDraggerMove(mouseEvent.clientX, mouseEvent.clientY);
        }
        this.setState({ dragging: true });
    }
    handleDragEnd() {
        this.setState({ dragging: false });
    }
    handleMove(event) {
        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        if (event.type === 'mousemove') {
            const mouseEvent = event;
            this.handleDraggerMove(mouseEvent.clientX, mouseEvent.clientY);
            return;
        }
        const touchEvent = event;
        this.handleDraggerMove(touchEvent.touches[0].clientX, touchEvent.touches[0].clientY);
    }
    handleDraggerMove(x, y) {
        if (this.node == null) {
            return;
        }
        const { onChange } = this.props;
        const rect = this.node.getBoundingClientRect();
        const offsetX = x - rect.left;
        const offsetY = y - rect.top;
        onChange({ x: offsetX, y: offsetY });
    }
}
__decorate([autobind], Slidable.prototype, "setDraggerNode", null);
__decorate([autobind], Slidable.prototype, "setNode", null);
__decorate([autobind], Slidable.prototype, "startDrag", null);
__decorate([autobind], Slidable.prototype, "handleDragEnd", null);
__decorate([autobind], Slidable.prototype, "handleMove", null);
__decorate([autobind], Slidable.prototype, "handleDraggerMove", null);

const VERTICAL_PADDING = 13;
class HuePicker extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragging: false,
            sliderHeight: 0,
            draggerHeight: 0
        };
    }
    render() {
        const { hue } = this.props;
        const { sliderHeight, draggerHeight } = this.state;
        const offset = offsetForHue(hue, sliderHeight, draggerHeight);
        const draggerY = clamp(offset, 0, sliderHeight);
        return createElement(
            'div',
            { className: styles$23.HuePicker, ref: this.setSliderHeight },
            createElement(Slidable, { draggerY: draggerY, draggerX: 0, onChange: this.handleChange, onDraggerHeight: this.setDraggerHeight })
        );
    }
    setSliderHeight(node) {
        if (node == null) {
            return;
        }
        this.setState({ sliderHeight: node.clientHeight });
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                this.setState({ sliderHeight: node.clientHeight });
            }, 0);
        }
    }
    setDraggerHeight(height) {
        this.setState({
            draggerHeight: height
        });
    }
    handleChange({ y }) {
        const { onChange } = this.props;
        const { sliderHeight } = this.state;
        const offsetY = clamp(y, 0, sliderHeight);
        const hue = hueForOffset(offsetY, sliderHeight);
        onChange(hue);
    }
}
__decorate([autobind], HuePicker.prototype, "setSliderHeight", null);
__decorate([autobind], HuePicker.prototype, "setDraggerHeight", null);
__decorate([autobind], HuePicker.prototype, "handleChange", null);
function offsetForHue(hue, sliderHeight, draggerHeight) {
    const slidableArea = sliderHeight - (draggerHeight + VERTICAL_PADDING);
    return clamp(hue / 360 * slidableArea + VERTICAL_PADDING, 0, sliderHeight - draggerHeight);
}
function hueForOffset(offset, sliderHeight) {
    const selectionHeight = offset - VERTICAL_PADDING;
    const slidableArea = sliderHeight - 2 * VERTICAL_PADDING;
    return clamp(selectionHeight / slidableArea * 360, 0, 360);
}

const VERTICAL_PADDING$1 = 13;
class AlphaPicker extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragging: false,
            sliderHeight: 0,
            draggerHeight: 0
        };
    }
    render() {
        const { color, alpha } = this.props;
        const { sliderHeight, draggerHeight } = this.state;
        const offset = offsetForAlpha(alpha, sliderHeight, draggerHeight);
        const draggerY = clamp(offset, 0, sliderHeight);
        const background = alphaGradientForColor(color);
        return createElement(
            'div',
            { className: styles$23.AlphaPicker, ref: this.setSliderHeight },
            createElement('div', { className: styles$23.ColorLayer, style: { background } }),
            createElement(Slidable, { draggerY: draggerY, draggerX: 0, onChange: this.handleChange, onDraggerHeight: this.setDraggerHeight })
        );
    }
    setSliderHeight(node) {
        if (node == null) {
            return;
        }
        this.setState({ sliderHeight: node.clientHeight });
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                this.setState({ sliderHeight: node.clientHeight });
            }, 0);
        }
    }
    setDraggerHeight(height) {
        this.setState({
            draggerHeight: height
        });
    }
    handleChange({ y }) {
        const { onChange } = this.props;
        const { sliderHeight } = this.state;
        const offsetY = clamp(y, 0, sliderHeight);
        const alpha = alphaForOffset(offsetY, sliderHeight);
        onChange(alpha);
    }
}
__decorate([autobind], AlphaPicker.prototype, "setSliderHeight", null);
__decorate([autobind], AlphaPicker.prototype, "setDraggerHeight", null);
__decorate([autobind], AlphaPicker.prototype, "handleChange", null);
function alphaForOffset(offset, sliderHeight) {
    const selectionHeight = offset - VERTICAL_PADDING$1;
    const slidableArea = sliderHeight - 2 * VERTICAL_PADDING$1;
    return clamp(1 - selectionHeight / slidableArea, 0, 1);
}
function offsetForAlpha(alpha, sliderHeight, draggerHeight) {
    const slidableArea = sliderHeight - (draggerHeight + VERTICAL_PADDING$1);
    return clamp((1 - alpha) * slidableArea + VERTICAL_PADDING$1, 0, sliderHeight - draggerHeight);
}
function alphaGradientForColor(color) {
    const { red, green, blue } = hsbToRgb(color);
    const rgb = `${red}, ${green}, ${blue}`;
    return `linear-gradient(to top, rgba(${rgb}, 0) 18px, rgba(${rgb}, 1) calc(100% - 18px))`;
}

class ColorPicker$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            pickerSize: 0
        };
        this.colorNode = null;
    }
    componentDidMount() {
        const { colorNode } = this;
        if (colorNode == null) {
            return;
        }
        this.setState({ pickerSize: colorNode.clientWidth });
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                this.setState({ pickerSize: colorNode.clientWidth });
            }, 0);
        }
    }
    render() {
        const { color, allowAlpha } = this.props;
        const { hue, saturation, brightness, alpha: providedAlpha } = color;
        const { pickerSize } = this.state;
        const alpha = providedAlpha != null && allowAlpha ? providedAlpha : 1;
        const { red, green, blue } = hsbToRgb({ hue, saturation: 1, brightness: 1 });
        const colorString = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
        const draggerX = clamp(saturation * pickerSize, 0, pickerSize);
        const draggerY = clamp(pickerSize - brightness * pickerSize, 0, pickerSize);
        const alphaSliderMarkup = allowAlpha ? createElement(AlphaPicker, { alpha: alpha, color: color, onChange: this.handleAlphaChange }) : null;
        return createElement(
            'div',
            { className: styles$23.ColorPicker },
            createElement(
                'div',
                { ref: this.setColorNode, className: styles$23.MainColor },
                createElement('div', { className: styles$23.ColorLayer, style: { backgroundColor: colorString } }),
                createElement(Slidable, { onChange: this.handleDraggerMove, draggerX: draggerX, draggerY: draggerY })
            ),
            createElement(HuePicker, { hue: hue, onChange: this.handleHueChange }),
            alphaSliderMarkup
        );
    }
    setColorNode(node) {
        this.colorNode = node;
    }
    handleHueChange(hue) {
        const { color: { brightness, saturation, alpha = 1 }, onChange } = this.props;
        onChange({ hue, brightness, saturation, alpha });
    }
    handleAlphaChange(alpha) {
        const { color: { hue, brightness, saturation }, onChange } = this.props;
        onChange({ hue, brightness, saturation, alpha });
    }
    handleDraggerMove({ x, y }) {
        const { pickerSize } = this.state;
        const { color: { hue, alpha = 1 }, onChange } = this.props;
        const saturation = clamp(x / pickerSize, 0, 1);
        const brightness = clamp(1 - y / pickerSize, 0, 1);
        onChange({ hue, saturation, brightness, alpha });
    }
}
__decorate([autobind], ColorPicker$1.prototype, "setColorNode", null);
__decorate([autobind], ColorPicker$1.prototype, "handleHueChange", null);
__decorate([autobind], ColorPicker$1.prototype, "handleAlphaChange", null);
__decorate([autobind], ColorPicker$1.prototype, "handleDraggerMove", null);

var styles$24 = {
  "DatePicker": "p_dc",
  "MonthContainer": "p_ry",
  "Month": "p_st",
  "Week": "p_il",
  "WeekHeadings": "p_d9",
  "Day": "p_k2",
  "EmptyDay": "p_pz",
  "Day-inRange": "p_cz",
  "Day-selected": "p_ty",
  "Day-disabled": "p_ib",
  "Weekday": "p_d4",
  "Header": "p_oq",
  "Title": "p_yc",
};

class Day extends PureComponent {
    constructor() {
        super(...arguments);
        this.dayNode = null;
    }
    componentDidUpdate() {
        if (this.props.focused && this.dayNode) {
            this.dayNode.focus();
        }
    }
    render() {
        const { day, focused, onClick, onHover = noop, onFocus = noop, selected, inRange, inHoveringRange, disabled } = this.props;
        const handleHover = onHover.bind(null, day);
        if (!day) {
            return createElement('div', { className: styles$24.EmptyDay, onMouseOver: handleHover });
        }
        const handleClick = onClick && !disabled ? onClick.bind(null, day) : noop;
        const className = classNames(styles$24.Day, selected && styles$24['Day-selected'], disabled && styles$24['Day-disabled'], (inRange || inHoveringRange) && !disabled && styles$24['Day-inRange']);
        const date = day.getDate();
        const tabIndex = (focused || selected || date === 1) && !disabled ? 0 : -1;
        return createElement(
            'button',
            { onFocus: onFocus.bind(null, day), ref: this.setNode, tabIndex: tabIndex, className: className, onMouseOver: handleHover, onClick: handleClick, 'aria-label': `${Months[day.getMonth()]} ${day.getFullYear()}`, 'aria-selected': selected, 'aria-disabled': disabled, role: 'gridcell' },
            date
        );
    }
    setNode(node) {
        this.dayNode = node;
    }
}
__decorate([autobind], Day.prototype, "setNode", null);

function Weekday({ label, title }) {
    return createElement(
        'div',
        { 'aria-label': Weekdays[label], className: styles$24.Weekday },
        title
    );
}

const WEEKDAYS = [Weekdays.Sunday, Weekdays.Monday, Weekdays.Tuesday, Weekdays.Wednesday, Weekdays.Thursday, Weekdays.Friday, Weekdays.Saturday];
function Month({ focusedDate, selected, hoverDate, disableDatesBefore, disableDatesAfter, allowRange, onChange = noop, onHover = noop, onFocus = noop, month, year }) {
    const isInHoveringRange = allowRange ? hoveringDateIsInRange : () => false;
    const weeks = getWeeksForMonth(month, year);
    const weekdays = WEEKDAYS.map(weekday => createElement(Weekday, { key: weekday, title: abbreviationForWeekday(weekday), label: weekday }));
    function handleDateClick(selectedDate) {
        onChange(getNewRange(selected, selectedDate));
    }
    function renderWeek(day, dayIndex) {
        if (day == null) {
            const lastDayOfMonth = new Date(year, month + 1, 0);
            return createElement(Day, { key: dayIndex, onHover: onHover.bind(null, lastDayOfMonth) });
        }
        const disabled = disableDatesBefore && isDateBefore(day, disableDatesBefore) || disableDatesAfter && isDateAfter(day, disableDatesAfter);
        return createElement(Day, { focused: focusedDate != null && isSameDay(day, focusedDate), day: day, key: dayIndex, onFocus: onFocus, onClick: handleDateClick, onHover: onHover, selected: selected != null && dateIsSelected(day, selected), inRange: selected != null && dateIsInRange(day, selected), disabled: disabled, inHoveringRange: selected != null && hoverDate != null && isInHoveringRange(day, selected, hoverDate) });
    }
    const weeksMarkup = weeks.map((week, index) => createElement(
        'div',
        { role: 'row', className: styles$24.Week, key: index },
        week.map(renderWeek)
    ));
    return createElement(
        'div',
        { role: 'grid', className: styles$24.Month },
        createElement(
            'div',
            { className: styles$24.Title },
            Months[month],
            ' ',
            year
        ),
        createElement(
            'div',
            { role: 'rowheader', className: styles$24.WeekHeadings },
            weekdays
        ),
        weeksMarkup
    );
}
function hoveringDateIsInRange(day, range, hoverEndDate) {
    if (day == null) {
        return false;
    }
    const { start, end } = range;
    return Boolean(start === end && day > start && day <= hoverEndDate);
}

class DatePicker$1 extends PureComponent {
    constructor(props) {
        super(props);
        const { selected } = props;
        const range = selected instanceof Date ? { start: selected, end: selected } : selected;
        this.state = {
            hoverDate: range && range.end
        };
    }
    render() {
        const { month, year, multiMonth, disableDatesBefore, disableDatesAfter, selected } = this.props;
        const { hoverDate, focusDate } = this.state;
        const allowRange = selected != null && !(selected instanceof Date);
        const range = selected != null && selected instanceof Date ? { start: selected, end: selected } : selected;
        const showNextYear = getNextDisplayYear(month, year);
        const showNextMonth = getNextDisplayMonth(month);
        const showNextToNextYear = getNextDisplayYear(showNextMonth, showNextYear);
        const showNextToNextMonth = getNextDisplayMonth(showNextMonth);
        const showPreviousYear = getPreviousDisplayYear(month, year);
        const showPreviousMonth = getPreviousDisplayMonth(month);
        const previousMonthName = Months[showPreviousMonth];
        const nextMonth = multiMonth ? Months[showNextToNextMonth] : Months[showNextMonth];
        const nextYear = multiMonth ? showNextToNextYear : showNextYear;
        const secondDatePicker = multiMonth ? createElement(Month, { onFocus: this.handleFocus, focusedDate: focusDate, month: showNextMonth, year: showNextYear, selected: range, hoverDate: hoverDate, onChange: this.handleDateSelection, onHover: this.handleHover, disableDatesBefore: disableDatesBefore, disableDatesAfter: disableDatesAfter, allowRange: allowRange }) : null;
        return createElement(
            'div',
            { className: styles$24.DatePicker, onKeyDown: handleKeyDown, onKeyUp: this.handleKeyUp },
            createElement(
                'div',
                { className: styles$24.Header },
                createElement(Button$1, { plain: true, icon: 'arrowLeft', accessibilityLabel: `Show previous month, ${previousMonthName} ${showPreviousYear}`, onClick: this.handleMonthChangeClick.bind(null, showPreviousMonth, showPreviousYear) }),
                createElement(Button$1, { plain: true, icon: 'arrowRight', accessibilityLabel: `Show next month, ${nextMonth} ${nextYear}`, onClick: this.handleMonthChangeClick.bind(null, showNextMonth, showNextYear) })
            ),
            createElement(
                'div',
                { className: styles$24.MonthContainer },
                createElement(Month, { onFocus: this.handleFocus, focusedDate: focusDate, month: month, year: year, selected: range, hoverDate: hoverDate, onChange: this.handleDateSelection, onHover: this.handleHover, disableDatesBefore: disableDatesBefore, disableDatesAfter: disableDatesAfter, allowRange: allowRange }),
                secondDatePicker
            )
        );
    }
    handleFocus(date) {
        this.setState({
            focusDate: date
        });
    }
    handleKeyUp(event) {
        const { key } = event;
        const { selected, disableDatesBefore, disableDatesAfter } = this.props;
        const { focusDate } = this.state;
        const range = selected instanceof Date ? { start: selected, end: selected } : selected;
        const focusedDate = focusDate || range && range.start;
        if (focusedDate == null) {
            return;
        }
        if (key === 'ArrowUp') {
            const previousWeek = new Date(focusedDate);
            previousWeek.setDate(focusedDate.getDate() - 7);
            if (!(disableDatesBefore && isDateBefore(previousWeek, disableDatesBefore))) {
                this.setFocusDateAndHandleMonthChange(previousWeek);
            }
        }
        if (key === 'ArrowDown') {
            const nextWeek = new Date(focusedDate);
            nextWeek.setDate(focusedDate.getDate() + 7);
            if (!(disableDatesAfter && isDateAfter(nextWeek, disableDatesAfter))) {
                this.setFocusDateAndHandleMonthChange(nextWeek);
            }
        }
        if (key === 'ArrowRight') {
            const tomorrow = new Date(focusedDate);
            tomorrow.setDate(focusedDate.getDate() + 1);
            if (!(disableDatesAfter && isDateAfter(tomorrow, disableDatesAfter))) {
                this.setFocusDateAndHandleMonthChange(tomorrow);
            }
        }
        if (key === 'ArrowLeft') {
            const yesterday = new Date(focusedDate);
            yesterday.setDate(focusedDate.getDate() - 1);
            if (!(disableDatesBefore && isDateBefore(yesterday, disableDatesBefore))) {
                this.setFocusDateAndHandleMonthChange(yesterday);
            }
        }
    }
    setFocusDateAndHandleMonthChange(date) {
        const { onMonthChange } = this.props;
        if (onMonthChange) {
            onMonthChange(date.getMonth(), date.getFullYear());
        }
        this.setState({
            hoverDate: date,
            focusDate: date
        });
    }
    handleDateSelection(selected) {
        const { end: endDate } = selected;
        const { onChange = noop } = this.props;
        this.setState({
            hoverDate: endDate,
            focusDate: new Date(endDate)
        });
        onChange(selected);
    }
    handleMonthChangeClick(month, year) {
        const { onMonthChange } = this.props;
        if (!onMonthChange) {
            return;
        }
        this.setState({
            focusDate: undefined
        });
        onMonthChange(month, year);
    }
    handleHover(date) {
        this.setState({
            hoverDate: date
        });
    }
}
__decorate([autobind], DatePicker$1.prototype, "handleFocus", null);
__decorate([autobind], DatePicker$1.prototype, "handleKeyUp", null);
__decorate([autobind], DatePicker$1.prototype, "setFocusDateAndHandleMonthChange", null);
__decorate([autobind], DatePicker$1.prototype, "handleDateSelection", null);
__decorate([autobind], DatePicker$1.prototype, "handleMonthChangeClick", null);
__decorate([autobind], DatePicker$1.prototype, "handleHover", null);
function handleKeyDown(event) {
    const { key } = event;
    if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
    }
}

var styles$25 = {
  "DescriptionList": "p_i0",
  "Term": "p_od",
  "Description": "p_wu",
};

function DescriptionList$1({ items }) {
    const terms = items.reduce((allTerms, { term, description }) => [...allTerms, createElement(
        'dt',
        { key: `${term}-term`, className: styles$25.Term },
        term
    ), createElement(
        'dd',
        { key: `${term}-description`, className: styles$25.Description },
        description
    )], []);
    return createElement(
        'dl',
        { className: styles$25.DescriptionList },
        terms
    );
}

var styles$26 = {
  "DisplayText": "p_fs",
  "sizeSmall": "p_d8",
  "sizeMedium": "p_bz",
  "sizeLarge": "p_ci",
  "sizeExtraLarge": "p_qd",
};

function DisplayText$1({ element: Element = 'p', children, size = 'medium' }) {
    const className = classNames(styles$26.DisplayText, size && styles$26[variationName('size', size)]);
    return createElement(
        Element,
        { className: className },
        children
    );
}

var styles$27 = {
  "EmptyState": "p_tc",
  "imageContained": "p_z5",
  "Image": "p_is",
  "Section": "p_ay",
  "ImageContainer": "p_gf",
  "DetailsContainer": "p_py",
  "Details": "p_t2",
  "Content": "p_jr",
  "Actions": "p_nb",
};

class EmptyState$1 extends PureComponent {
  render() {
    const { children, heading, image, largeImage, imageContained, action, secondaryAction } = this.props;
    const className = classNames(styles$27.EmptyState, imageContained && styles$27.imageContained);
    const imageMarkup = largeImage ? createElement(Image$1, { alt: '', role: 'presentation', className: styles$27.Image, source: largeImage, sourceSet: [{ source: image, descriptor: '568w' }, { source: largeImage, descriptor: '1136w' }], sizes: '(max-width: 568px) 60vw' }) : createElement(Image$1, { role: 'presentation', alt: '', className: styles$27.Image, source: image });
    const secondaryActionMarkup = secondaryAction ? buttonFrom(secondaryAction, { plain: true }) : null;
    return createElement(
      'div',
      { className: className },
      createElement(
        'div',
        { className: styles$27.Section },
        createElement(
          'div',
          { className: styles$27.DetailsContainer },
          createElement(
            'div',
            { className: styles$27.Details },
            createElement(
              TextContainer$1,
              null,
              createElement(
                DisplayText$1,
                { size: 'medium' },
                heading
              ),
              createElement(
                'div',
                { className: styles$27.Content },
                children
              )
            ),
            createElement(
              'div',
              { className: styles$27.Actions },
              createElement(
                ButtonGroup$1,
                null,
                buttonFrom(action, { primary: true, size: 'large' }),
                secondaryActionMarkup
              )
            )
          )
        ),
        createElement(
          'div',
          { className: styles$27.ImageContainer },
          imageMarkup
        )
      )
    );
  }
}

var helpIcon = {"viewBox":"0 0 20 20","body":"<circle cx=\"10\" cy=\"10\" r=\"9\" fill=\"currentColor\"/><path d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8m0-4a1 1 0 1 0 0 2 1 1 0 1 0 0-2m0-10C8.346 4 7 5.346 7 7a1 1 0 1 0 2 0 1.001 1.001 0 1 1 1.591.808C9.58 8.548 9 9.616 9 10.737V11a1 1 0 1 0 2 0v-.263c0-.653.484-1.105.773-1.317A3.013 3.013 0 0 0 13 7c0-1.654-1.346-3-3-3\" />"};

var styles$28 = {
  "FooterHelp": "p_yi",
  "Content": "p_eq",
  "Icon": "p_tu",
  "Text": "p_ki",
};

function FooterHelp$1({ children }) {
  return createElement(
    'div',
    { className: styles$28.FooterHelp },
    createElement(
      'div',
      { className: styles$28.Content },
      createElement(
        'div',
        { className: styles$28.Icon },
        createElement(Icon$1, { source: helpIcon, color: 'teal', backdrop: true })
      ),
      createElement(
        'div',
        { className: styles$28.Text },
        children
      )
    )
  );
}

var styles$29 = {
  "FormLayout": "p_kz",
  "condensed": "p_mi",
  "Item": "p_fd",
  "Title": "p_ra",
  "Items": "p_ak",
  "HelpText": "p_vg",
};

function Item$3(props) {
    return createElement(
        'div',
        { className: styles$29.Item },
        props.children
    );
}

const getUniqueID$3 = createUniqueIDFactory('FormLayoutGroup');
function Group({ children, condensed, title, helpText }) {
    const className = classNames(condensed && styles$29.condensed);
    const id = getUniqueID$3();
    let helpTextElement = null;
    let helpTextID;
    let titleElement = null;
    let titleID;
    if (helpText) {
        helpTextID = `${id}HelpText`;
        helpTextElement = createElement(
            'div',
            { id: helpTextID, className: styles$29.HelpText },
            helpText
        );
    }
    if (title) {
        titleID = `${id}Title`;
        titleElement = createElement(
            'div',
            { id: titleID, className: styles$29.Title },
            title
        );
    }
    const itemsMarkup = Children.map(children, child => wrapWithComponent(child, Item$3));
    return createElement(
        'div',
        { role: 'group', className: className, 'aria-labelledby': titleID, 'aria-describedby': helpTextID },
        titleElement,
        createElement(
            'div',
            { className: styles$29.Items },
            itemsMarkup
        ),
        helpTextElement
    );
}

class FormLayout$1 extends PureComponent {
    render() {
        const { children } = this.props;
        return createElement(
            'div',
            { className: styles$29.FormLayout },
            Children.map(children, wrapChildren)
        );
    }
}
FormLayout$1.Group = Group;
function wrapChildren(child, index) {
    if (isElementOfType(child, Group)) {
        return child;
    }
    return wrapWithComponent(child, Item$3, { key: index });
}

var styles$30 = {
  "KeyboardKey": "p_l3",
};

function KeyboardKey$1({ children }) {
    let key = children || '';
    key = key.length > 1 ? key.toLowerCase() : key.toUpperCase();
    return createElement(
        'kbd',
        { className: styles$30.KeyboardKey },
        key
    );
}

class KeypressListener$1 extends Component {
    componentDidMount() {
        addEventListener(document, 'keyup', this.handleKeyEvent);
    }
    componentWillUnmount() {
        removeEventListener(document, 'keyup', this.handleKeyEvent);
    }
    // tslint:disable-next-line prefer-function-over-method
    render() {
        return null;
    }
    handleKeyEvent(event) {
        const { keyCode, handler } = this.props;
        if (event.keyCode === keyCode) {
            handler(event);
        }
    }
}
__decorate([autobind], KeypressListener$1.prototype, "handleKeyEvent", null);

var styles$31 = {
  "Label": "p_l8",
  "hidden": "p_v1",
  "Text": "p_je",
};

function labelID(id) {
    return `${id}Label`;
}
function Label$1({ children, id, action, hidden }) {
    const className = classNames(styles$31.Label, hidden && styles$31.hidden);
    const actionMarkup = action ? buttonFrom(action, { plain: true }) : null;
    return createElement(
        'div',
        { className: className },
        createElement(
            'label',
            { id: labelID(id), htmlFor: id, className: styles$31.Text },
            children
        ),
        actionMarkup
    );
}

var styles$32 = {
  "Layout": "p_bv",
  "Section": "p_iu",
  "Section-secondary": "p_kk",
  "AnnotatedSection": "p_sn",
  "AnnotationWrapper": "p_q7",
  "AnnotationContent": "p_hz",
  "Annotation": "p_v9",
};

function Section$1({ children, secondary }) {
    const className = classNames(styles$32.Section, secondary && styles$32['Section-secondary']);
    return createElement(
        'div',
        { className: className },
        children
    );
}

function AnnotatedSection(props) {
  const { children, title, description } = props;
  const wrappedDescription = typeof description === 'string' ? createElement(
    'p',
    null,
    description
  ) : description;
  return createElement(
    'div',
    { className: styles$32.AnnotatedSection },
    createElement(
      'div',
      { className: styles$32.AnnotationWrapper },
      createElement(
        'div',
        { className: styles$32.Annotation },
        createElement(
          TextContainer$1,
          null,
          createElement(
            Heading$1,
            null,
            title
          ),
          wrappedDescription
        )
      ),
      createElement(
        'div',
        { className: styles$32.AnnotationContent },
        children
      )
    )
  );
}

class Layout$1 extends Component {
    render() {
        const { children, sectioned } = this.props;
        const content = sectioned ? createElement(
            Section$1,
            null,
            children
        ) : children;
        return createElement(
            'div',
            { className: styles$32.Layout },
            content
        );
    }
}
Layout$1.AnnotatedSection = AnnotatedSection;
Layout$1.Section = Section$1;

var styles$33 = {
  "Link": "p_yr",
};

function Link$1({ url, children, onClick, external }) {
  return url ? createElement(
    UnstyledLink$1,
    { className: styles$33.Link, url: url, external: external },
    children
  ) : createElement(
    'button',
    { onClick: onClick, className: styles$33.Link },
    children
  );
}

var styles$34 = {
  "List": "p_kl",
  "typeBullet": "p_fe",
  "Item": "p_wz",
  "typeNumber": "p_da",
};

function Item$4({ children }) {
    return createElement(
        'li',
        { className: styles$34.Item },
        children
    );
}

class ContentList extends PureComponent {
    render() {
        const { children, type = 'bullet' } = this.props;
        const className = classNames(styles$34.List, type && styles$34[variationName('type', type)]);
        const ListElement = type === 'bullet' ? 'ul' : 'ol';
        return createElement(
            ListElement,
            { className: className },
            children
        );
    }
}
ContentList.Item = Item$4;

var styles$35 = {
  "Breadcrumb": "p_ob",
  "Icon": "p_fj",
  "Content": "p_a0",
};

class Breadcrumbs$1 extends PureComponent {
    render() {
        const { breadcrumbs } = this.props;
        const breadcrumb = breadcrumbs[breadcrumbs.length - 1];
        if (breadcrumb == null) {
            return null;
        }
        const { content, url } = breadcrumb;
        return createElement(
            'nav',
            { role: 'navigation' },
            createElement(
                UnstyledLink$1,
                { key: content, url: url, className: styles$35.Breadcrumb, onMouseUp: handleMouseUpByBlurring },
                createElement(
                    'span',
                    { className: styles$35.Icon },
                    createElement(Icon$1, { source: 'chevronLeft' })
                ),
                createElement(
                    'span',
                    { className: styles$35.Content },
                    content
                )
            )
        );
    }
}

var styles$36 = {
  "Pagination": "p_vq",
  "plain": "p_ai",
  "Button": "p_q0",
};

function Pagination$1({ hasNext, hasPrevious, nextURL, previousURL, onNext, onPrevious, plain }) {
  const className = classNames$1(styles$36.Pagination, plain && styles$36.plain);
  const previousButton = previousURL ? createElement(
    UnstyledLink$1,
    { className: styles$36.Button, url: previousURL, onMouseUp: handleMouseUpByBlurring, 'aria-label': 'Previous' },
    createElement(Icon$1, { source: 'arrowLeft' })
  ) : createElement(
    'button',
    { onClick: onPrevious, onMouseUp: handleMouseUpByBlurring, className: styles$36.Button, 'aria-label': 'Previous', disabled: !hasPrevious },
    createElement(Icon$1, { source: 'arrowLeft' })
  );
  const nextButton = nextURL ? createElement(
    UnstyledLink$1,
    { className: styles$36.Button, url: nextURL, onMouseUp: handleMouseUpByBlurring, 'aria-label': 'Next' },
    createElement(Icon$1, { source: 'arrowRight' })
  ) : createElement(
    'button',
    { onClick: onNext, onMouseUp: handleMouseUpByBlurring, className: styles$36.Button, 'aria-label': 'Next', disabled: !hasNext },
    createElement(Icon$1, { source: 'arrowRight' })
  );
  return createElement(
    'span',
    { className: className },
    previousButton,
    nextButton
  );
}

var styles$37 = {
  "Scrollable": "p_f9",
  "horizontal": "p_cx",
  "vertical": "p_oi",
  "hasTopShadow": "p_pg",
  "hasBottomShadow": "p_d3",
};

class Scrollable$1 extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            topShadow: false,
            bottomShadow: false
        };
    }
    static forNode(node) {
        return closest(node, scrollable.selector) || document;
    }
    componentDidMount() {
        if (this.scrollArea == null || !this.props.shadow) {
            return;
        }
        addEventListener(this.scrollArea, 'scroll', this.handleScroll);
        this.handleScroll();
    }
    componentWillUnmount() {
        if (this.scrollArea == null || !this.props.shadow) {
            return;
        }
        removeEventListener(this.scrollArea, 'scroll', this.handleScroll);
    }
    render() {
        const { topShadow, bottomShadow } = this.state;
        const _a = this.props,
              { children, className, horizontal, vertical = true, shadow } = _a,
              rest = __rest(_a, ["children", "className", "horizontal", "vertical", "shadow"]);
        const finalClassName = classNames(className, styles$37.Scrollable, vertical && styles$37.vertical, horizontal && styles$37.horizontal, topShadow && styles$37.hasTopShadow, bottomShadow && styles$37.hasBottomShadow);
        return createElement(
            'div',
            Object.assign({ className: finalClassName }, scrollable.props, rest, { ref: this.setScrollArea }),
            children
        );
    }
    setScrollArea(scrollArea) {
        this.scrollArea = scrollArea;
    }
    handleScroll() {
        const { scrollArea } = this;
        if (scrollArea == null || !this.props.shadow) {
            return;
        }
        const { scrollTop, clientHeight, scrollHeight } = scrollArea;
        const shouldBottomShadow = !(scrollTop + clientHeight >= scrollHeight);
        const shouldTopShadow = scrollTop > 0;
        this.setState({
            topShadow: shouldTopShadow,
            bottomShadow: shouldBottomShadow
        });
    }
}
__decorate([autobind], Scrollable$1.prototype, "setScrollArea", null);
__decorate([autobind], Scrollable$1.prototype, "handleScroll", null);

function calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition) {
    const activatorTop = activatorRect.top;
    const activatorBottom = activatorTop + activatorRect.height;
    const spaceAbove = activatorRect.top;
    const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;
    const desiredHeight = overlayRect.height;
    const verticalMargins = overlayMargins.activator + overlayMargins.container;
    const minimumSpaceToScroll = overlayMargins.container;
    const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);
    const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);
    const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;
    const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;
    const heightIfBelow = Math.min(spaceBelow, desiredHeight);
    const heightIfAbove = Math.min(spaceAbove, desiredHeight);
    const positionIfAbove = {
        height: heightIfAbove - verticalMargins,
        top: activatorTop + containerRect.top - heightIfAbove,
        positioning: 'above'
    };
    const positionIfBelow = {
        height: heightIfBelow - verticalMargins,
        top: activatorBottom + containerRect.top,
        positioning: 'below'
    };
    if (preferredPosition === 'above') {
        return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;
    }
    if (preferredPosition === 'below') {
        return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;
    }
    if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {
        return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;
    }
    return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;
}
function calculateHorizontalPosition(activatorRect, overlayRect, containerRect) {
    const maximum = containerRect.width - overlayRect.width;
    return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));
}
function rectIsOutsideOfRect(inner, outer) {
    const { center } = inner;
    return center.y < outer.top || center.y > outer.top + outer.height;
}

var styles$38 = {
  "PositionedOverlay": "p_vl",
  "calculating": "p_ot",
};

class PositionedOverlay$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            measuring: true,
            activatorRect: getRectForNode(this.props.activator),
            left: 0,
            top: 0,
            height: 0,
            width: null,
            positioning: 'below',
            zIndex: null,
            outsideScrollableContainer: false
        };
    }
    componentDidMount() {
        this.scrollableContainer = Scrollable$1.forNode(this.props.activator);
        this.handleMeasurement();
    }
    componentDidUpdate() {
        const { outsideScrollableContainer, top } = this.state;
        const { onScrollOut, active } = this.props;
        if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {
            onScrollOut();
        }
    }
    render() {
        const { left, top, zIndex, width } = this.state;
        const { render } = this.props;
        const style = {
            top,
            left,
            width,
            zIndex: zIndex == null ? undefined : zIndex
        };
        return createElement(
            'div',
            { className: styles$38.PositionedOverlay, style: style, ref: this.setOverlay },
            createElement(EventListener$1, { event: 'resize', handler: this.handleMeasurement }),
            createElement(EventListener$1, { event: 'scroll', handler: this.handleMeasurement }),
            render(this.overlayDetails())
        );
    }
    overlayDetails() {
        const { measuring, left, positioning, height, activatorRect } = this.state;
        return {
            measuring,
            left,
            desiredHeight: height,
            positioning,
            activatorRect
        };
    }
    setOverlay(node) {
        this.overlay = node;
    }
    handleMeasurement() {
        this.setState({
            left: 0,
            top: 0,
            height: 0,
            positioning: 'below',
            measuring: true
        }, () => {
            if (this.overlay == null || this.scrollableContainer == null) {
                return;
            }
            const { activator, preferredPosition = 'below', onScrollOut, fullWidth } = this.props;
            const activatorRect = getRectForNode(activator);
            const currentOverlayRect = getRectForNode(this.overlay);
            const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;
            const scrollableContainerRect = getRectForNode(scrollableElement);
            const overlayRect = fullWidth ? Object.assign({}, currentOverlayRect, { width: activatorRect.width }) : currentOverlayRect;
            // If `body` is 100% height, it still acts as though it were not constrained
            // to that size. This adjusts for that.
            if (scrollableElement === document.body) {
                scrollableContainerRect.height = document.body.scrollHeight;
            }
            const overlayMargins = this.overlay.firstElementChild ? getMarginsForNode(this.overlay.firstElementChild) : { activator: 0, container: 0, horizontal: 0 };
            const containerRect = windowRect();
            const zIndexForLayer = getZIndexForLayerFromNode(activator);
            const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;
            const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition);
            const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect);
            this.setState({
                measuring: false,
                activatorRect: getRectForNode(activator),
                left: horizontalPosition,
                top: verticalPosition.top,
                height: verticalPosition.height,
                width: fullWidth ? overlayRect.width : null,
                positioning: verticalPosition.positioning,
                outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),
                zIndex
            });
        });
    }
}
__decorate([autobind], PositionedOverlay$1.prototype, "overlayDetails", null);
__decorate([autobind], PositionedOverlay$1.prototype, "setOverlay", null);
__decorate([autobind], PositionedOverlay$1.prototype, "handleMeasurement", null);
function intersectionWithViewport(rect) {
    const viewport = windowRect();
    return new Rect({
        top: Math.max(rect.top, 0),
        left: Math.max(rect.left, 0),
        height: Math.min(rect.height - rect.top + viewport.top, viewport.height, viewport.height - rect.top),
        width: Math.min(rect.width - rect.left + viewport.left, viewport.width, viewport.width - rect.left)
    });
}
function getMarginsForNode(node) {
    const styles = window.getComputedStyle(node);
    return {
        activator: parseFloat(styles.marginTop || ''),
        container: parseFloat(styles.marginBottom || ''),
        horizontal: parseFloat(styles.marginLeft || '')
    };
}
function getZIndexForLayerFromNode(node) {
    const layerNode = closest(node, layer.selector) || document.body;
    const zIndex = parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);
    return isNaN(zIndex) ? null : zIndex;
}
function windowRect() {
    return new Rect({
        top: window.scrollY,
        left: window.scrollX,
        height: window.innerHeight,
        width: window.innerWidth
    });
}
function isDocument(node) {
    return node === document;
}

var styles$39 = {
  "Popover": "p_of",
  "fullWidth": "p_qo",
  "Content": "p_jy",
  "measuring": "p_jt",
  "leaving": "p_px",
  "positionedAbove": "p_d7",
  "Tip": "p_cc",
  "Wrapper": "p_ge",
  "Pane": "p_yu",
  "Pane-fixed": "p_x0",
  "Section": "p_eg",
  "FocusTracker": "p_qu",
};

function Section$2({ children }) {
    return createElement(
        'div',
        { className: styles$39.Section },
        children
    );
}

function Pane({ fixed, sectioned, children }) {
    const className = classNames(styles$39.Pane, fixed && styles$39['Pane-fixed']);
    const content = sectioned ? wrapWithComponent(children, Section$2) : children;
    return fixed ? createElement(
        'div',
        { className: className },
        content
    ) : createElement(
        Scrollable$1,
        { className: className },
        content
    );
}

var CloseSource;
(function (CloseSource) {
    CloseSource[CloseSource["Click"] = 0] = "Click";
    CloseSource[CloseSource["EscapeKeypress"] = 1] = "EscapeKeypress";
    CloseSource[CloseSource["FocusOut"] = 2] = "FocusOut";
    CloseSource[CloseSource["ScrollOut"] = 3] = "ScrollOut";
})(CloseSource || (CloseSource = {}));
class PopoverOverlay extends PureComponent {
    componentDidUpdate({ active: wasActive }) {
        const { active, preventAutofocus } = this.props;
        if (!active || preventAutofocus || !active || active === wasActive) {
            return;
        }
        if (this.contentNode == null) {
            return;
        }
        write(() => {
            if (this.contentNode == null) {
                return;
            }
            const focusableChild = findFirstFocusableNode(this.contentNode);
            (focusableChild || this.contentNode).focus();
        });
    }
    render() {
        const { active } = this.props;
        const selector = `.${styles$39.Popover}`;
        const markup = active ? createElement(TransitionGroup.TransitionChild, { render: this.renderOverlay, selector: selector, skipAppearing: true, skipEntering: true }) : null;
        return createElement(
            TransitionGroup,
            null,
            markup
        );
    }
    renderOverlay(transitionStatus) {
        const { active, activator, fullWidth, preferredPosition = 'below' } = this.props;
        return createElement(PositionedOverlay$1, { fullWidth: fullWidth, active: active, activator: activator, preferredPosition: preferredPosition, render: this.renderPopover.bind(this, transitionStatus), onScrollOut: this.handleScrollOut });
    }
    renderPopover(transitionStatus, overlayDetails) {
        const { measuring, left, desiredHeight, positioning, activatorRect } = overlayDetails;
        const { id, children, sectioned, fullWidth } = this.props;
        const className = classNames(styles$39.Popover, transitionStatus && animationVariations(transitionStatus), positioning === 'above' && styles$39.positionedAbove, fullWidth && styles$39.fullWidth, measuring && styles$39.measuring);
        this.transitionStatus = transitionStatus;
        const tipMarkup = !measuring ? createElement('div', { style: { left: activatorRect.center.x - left }, className: styles$39.Tip }) : null;
        const contentStyles = measuring ? undefined : { height: desiredHeight };
        const content = createElement(
            'div',
            { id: id, tabIndex: -1, className: styles$39.Content, style: contentStyles, ref: this.setContentNode },
            renderPopoverContent(children, { sectioned })
        );
        return createElement(
            'div',
            Object.assign({ className: className }, overlay.props),
            createElement(EventListener$1, { event: 'click', handler: this.handleClick }),
            createElement(EventListener$1, { event: 'touchstart', handler: this.handleClick }),
            createElement(KeypressListener$1, { keyCode: Keys.ESCAPE, handler: this.handleEscape }),
            tipMarkup,
            createElement('div', { className: styles$39.FocusTracker, tabIndex: 0, onFocus: this.handleFocusFirstItem }),
            createElement(
                'div',
                { className: styles$39.Wrapper },
                content
            ),
            createElement('div', { className: styles$39.FocusTracker, tabIndex: 0, onFocus: this.handleFocusLastItem })
        );
    }
    setContentNode(node) {
        this.contentNode = node;
    }
    handleClick(event) {
        const target = event.target;
        const { contentNode, props: { activator, onClose } } = this;
        if (contentNode != null && nodeContainsDescendant(contentNode, target) || nodeContainsDescendant(activator, target) || this.transitionStatus !== TransitionStatus.Shown) {
            return;
        }
        onClose(CloseSource.Click);
    }
    handleScrollOut() {
        this.props.onClose(CloseSource.ScrollOut);
    }
    handleEscape() {
        this.props.onClose(CloseSource.EscapeKeypress);
    }
    handleFocusFirstItem() {
        this.props.onClose(CloseSource.FocusOut);
    }
    handleFocusLastItem() {
        this.props.onClose(CloseSource.FocusOut);
    }
}
__decorate([autobind], PopoverOverlay.prototype, "renderOverlay", null);
__decorate([autobind], PopoverOverlay.prototype, "renderPopover", null);
__decorate([autobind], PopoverOverlay.prototype, "setContentNode", null);
__decorate([autobind], PopoverOverlay.prototype, "handleClick", null);
__decorate([autobind], PopoverOverlay.prototype, "handleScrollOut", null);
__decorate([autobind], PopoverOverlay.prototype, "handleEscape", null);
__decorate([autobind], PopoverOverlay.prototype, "handleFocusFirstItem", null);
__decorate([autobind], PopoverOverlay.prototype, "handleFocusLastItem", null);
function renderPopoverContent(children, props) {
    const childrenArray = Children.toArray(children);
    if (isElementOfType(childrenArray[0], Pane)) {
        return childrenArray;
    }
    return wrapWithComponent(childrenArray, Pane, props);
}
function animationVariations(status) {
    switch (status) {
        case TransitionStatus.Leaving:
            return styles$39.leaving;
        default:
            return null;
    }
}

const getUniqueID$4 = createUniqueIDFactory('Popover');
let Popover$1 = class Popover extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            activatorFocused: false
        };
        this.id = getUniqueID$4();
    }
    componentDidMount() {
        this.setAccessibilityAttributes();
    }
    componentDidUpdate() {
        this.setAccessibilityAttributes();
    }
    renderLayer() {
        const _a = this.props,
              { children, onClose, activator, activatorWrapper } = _a,
              rest = __rest(_a, ["children", "onClose", "activator", "activatorWrapper"]);
        if (this.activatorNode == null) {
            return null;
        }
        return createElement(
            PopoverOverlay,
            Object.assign({ id: this.id, activator: this.activatorNode, onClose: this.handleClose }, rest),
            children
        );
    }
    render() {
        const { activatorWrapper: WrapperComponent = 'div' } = this.props;
        return createElement(
            WrapperComponent,
            { ref: this.setActivator },
            Children.only(this.props.activator)
        );
    }
    setAccessibilityAttributes() {
        const { id, activatorContainer } = this;
        if (activatorContainer == null) {
            return;
        }
        const firstFocusable = findFirstFocusableNode(activatorContainer);
        const focusableActivator = firstFocusable || activatorContainer;
        focusableActivator.tabIndex = focusableActivator.tabIndex || 0;
        focusableActivator.setAttribute('aria-controls', id);
        focusableActivator.setAttribute('aria-owns', id);
        focusableActivator.setAttribute('aria-haspopup', 'true');
        focusableActivator.setAttribute('aria-expanded', String(this.props.active));
    }
    handleClose(source) {
        this.props.onClose(source);
        if (this.activatorContainer == null) {
            return;
        }
        if (source === CloseSource.FocusOut || source === CloseSource.EscapeKeypress) {
            focusFirstFocusableNode(this.activatorContainer, false);
        }
    }
    setActivator(node) {
        if (node == null) {
            this.activatorNode = null;
            this.activatorContainer = null;
            return;
        }
        this.activatorNode = node.firstElementChild;
        this.activatorContainer = node;
    }
};
Popover$1.Pane = Pane;
Popover$1.Section = Section$2;
__decorate([autobind], Popover$1.prototype, "handleClose", null);
__decorate([autobind], Popover$1.prototype, "setActivator", null);
Popover$1 = __decorate([layeredComponent({ idPrefix: 'Popover' })], Popover$1);
var Popover$2 = Popover$1;

var styles$40 = {
  "Page": "p_le",
  "fullWidth": "p_o8",
  "Content": "p_na",
  "Header": "p_w2",
  "Header-hasPagination": "p_wo",
  "Header-hasBreadcrumbs": "p_fx",
  "Header-hasSecondaryActions": "p_ti",
  "Header-hasSeparator": "p_ou",
  "Header-hasRollup": "p_hv",
  "IndividualActions": "p_c2",
  "Rollup": "p_tg",
  "Navigation": "p_rr",
  "Pagination": "p_af",
  "MainContent": "p_ee",
  "TitleAndActions": "p_ia",
  "Title": "p_yk",
  "Actions": "p_y4",
  "SecondaryActions": "p_zb",
  "Action": "p_mn",
  "ActionGroup": "p_fz",
  "PrimaryAction": "p_zf",
  "ActionIcon": "p_aq",
  "ActionContent": "p_qr",
};

function Action({ icon, url, onAction, children, disclosure, accessibilityLabel }) {
    const iconMarkup = icon ? createElement(
        'span',
        { className: styles$40.ActionIcon },
        createElement(Icon$1, { source: icon })
    ) : null;
    const disclosureIconMarkup = disclosure ? createElement(
        'span',
        { className: styles$40.ActionIcon },
        createElement(Icon$1, { source: 'caretDown' })
    ) : null;
    const contentMarkup = iconMarkup || disclosureIconMarkup ? createElement(
        'span',
        { className: styles$40.ActionContent },
        iconMarkup,
        createElement(
            'span',
            null,
            children
        ),
        disclosureIconMarkup
    ) : children;
    if (url) {
        return createElement(
            UnstyledLink$1,
            { key: children, url: url, onMouseUp: handleMouseUpByBlurring, className: styles$40.Action, 'aria-label': accessibilityLabel },
            contentMarkup
        );
    }
    return createElement(
        'button',
        { key: children, onClick: onAction, onMouseUp: handleMouseUpByBlurring, className: styles$40.Action, 'aria-label': accessibilityLabel, type: 'button' },
        contentMarkup
    );
}

class Header$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            rollupOpen: false
        };
    }
    get hasRollup() {
        const { secondaryActions = [], actionGroups = [] } = this.props;
        return secondaryActions.length + actionGroups.length > 1;
    }
    render() {
        const { title, breadcrumbs = [], primaryAction, pagination, separator, secondaryActions } = this.props;
        const className = classNames(styles$40.Header, pagination && styles$40['Header-hasPagination'], separator && styles$40['Header-hasSeparator'], breadcrumbs && breadcrumbs.length && styles$40['Header-hasBreadcrumbs'], this.hasRollup && styles$40['Header-hasRollup'], secondaryActions && secondaryActions.length && styles$40['Header-hasSecondaryActions']);
        const breadcrumbMarkup = breadcrumbs.length > 0 ? createElement(Breadcrumbs$1, { breadcrumbs: breadcrumbs }) : null;
        const primaryActionMarkup = primaryAction ? createElement(
            'div',
            { className: styles$40.PrimaryAction },
            buttonsFrom(primaryAction, { primary: true })
        ) : null;
        const paginationMarkup = pagination ? createElement(
            'div',
            { className: styles$40.Pagination },
            createElement(Pagination$1, Object.assign({}, pagination, { plain: true }))
        ) : null;
        const nonPrimaryActionsMarkup = this.renderSecondaryActions();
        const actionsMarkup = createElement(
            'div',
            { className: styles$40.Actions },
            primaryActionMarkup,
            nonPrimaryActionsMarkup
        );
        const navigationMarkup = breadcrumbMarkup || paginationMarkup ? createElement(
            'div',
            { className: styles$40.Navigation },
            breadcrumbMarkup,
            paginationMarkup
        ) : null;
        const titleMarkup = createElement(
            'div',
            { className: styles$40.Title },
            createElement(
                DisplayText$1,
                { size: 'large', element: 'h1' },
                title
            )
        );
        return primaryActionMarkup ? createElement(
            'div',
            { className: className },
            navigationMarkup,
            createElement(
                'div',
                { className: styles$40.MainContent },
                createElement(
                    'div',
                    { className: styles$40.TitleAndActions },
                    titleMarkup,
                    actionsMarkup
                ),
                primaryActionMarkup
            )
        ) : createElement(
            'div',
            { className: className },
            navigationMarkup,
            titleMarkup,
            actionsMarkup
        );
    }
    renderSecondaryActions() {
        const { openActionGroup, rollupOpen } = this.state;
        const { secondaryActions = [], actionGroups = [] } = this.props;
        if (secondaryActions.length === 0 && actionGroups.length === 0) {
            return null;
        }
        const secondaryActionMarkup = secondaryActions.length > 0 ? secondaryActionsFrom(secondaryActions) : null;
        const actionGroupsMarkup = actionGroups.length > 0 ? actionGroups.map(({ title, icon, actions }) => createElement(
            'div',
            { className: styles$40.ActionGroup, key: `ActionGroup-${title}` },
            createElement(
                Popover$2,
                { key: title, active: title === openActionGroup, onClose: this.handleActionGroupClose.bind(this, title), activator: createElement(
                        Action,
                        { disclosure: true, icon: icon, onAction: this.handleActionGroupOpen.bind(this, title) },
                        title
                    ) },
                createElement(ActionList$1, { items: actions })
            )
        )) : null;
        const rollupMarkup = this.hasRollup ? createElement(
            'div',
            { className: styles$40.Rollup },
            createElement(
                Popover$2,
                { active: rollupOpen, onClose: this.handleRollupToggle, activator: createElement(
                        Button$1,
                        { disclosure: true, onClick: this.handleRollupToggle },
                        'Actions'
                    ) },
                createElement(ActionList$1, { items: secondaryActions, sections: actionGroups.map(convertActionGroupToActionListSection) })
            )
        ) : null;
        return createElement(
            'div',
            { className: styles$40.SecondaryActions },
            rollupMarkup,
            createElement(
                'div',
                { className: styles$40.IndividualActions },
                secondaryActionMarkup,
                actionGroupsMarkup
            )
        );
    }
    handleRollupToggle() {
        this.setState(({ rollupOpen }) => ({ rollupOpen: !rollupOpen }));
    }
    handleActionGroupClose(group) {
        this.setState(({ openActionGroup }) => openActionGroup === group ? { openActionGroup: undefined } : {});
    }
    handleActionGroupOpen(group) {
        this.setState({ openActionGroup: group });
    }
}
__decorate([autobind], Header$1.prototype, "handleRollupToggle", null);
function convertActionGroupToActionListSection({ title, actions }) {
    return { title, items: actions };
}
function secondaryActionsFrom(actions) {
    return actions.map((_a, index) => {
        var { content } = _a,
            action = __rest(_a, ["content"]);
        return createElement(
            Action,
            Object.assign({}, action, { key: `Action-${content || index}` }),
            content
        );
    });
}

const EASDK_PROPS = ['title', 'icon', 'breadcrumbs', 'secondaryActions', 'actionGroups', 'primaryAction', 'pagination'];
class Page$1 extends PureComponent {
    componentDidMount() {
        if (this.context.easdk == null) {
            return;
        }
        this.handleEASDKMessaging();
    }
    componentDidUpdate(prevProps) {
        if (this.context.easdk == null) {
            return;
        }
        const prevEASDKProps = pick(prevProps, EASDK_PROPS);
        const currentEASDKProps = pick(this.props, EASDK_PROPS);
        if (!isEqual(prevEASDKProps, currentEASDKProps)) {
            this.handleEASDKMessaging();
        }
    }
    render() {
        const _a = this.props,
              { children, fullWidth } = _a,
              rest = __rest(_a, ["children", "fullWidth"]);
        const className = classNames(styles$40.Page, fullWidth && styles$40.fullWidth);
        const headerMarkup = this.context.easdk ? null : createElement(Header$1, rest);
        return createElement(
            'div',
            { className: className },
            headerMarkup,
            createElement(
                'div',
                { className: styles$40.Content },
                children
            )
        );
    }
    handleEASDKMessaging() {
        const { easdk } = this.context;
        if (easdk) {
            easdk.Bar.update(this.props);
        }
    }
}
Page$1.contextTypes = { easdk: object };

var styles$41 = {
  "PageActions": "p_cu",
};

function PageActions$1({ primaryAction, secondaryActions }) {
    const primaryActionMarkup = primaryAction ? buttonsFrom(primaryAction, { primary: true }) : null;
    const secondaryActionsMarkup = secondaryActions ? createElement(
        ButtonGroup$1,
        null,
        buttonsFrom(secondaryActions)
    ) : null;
    const distribution = secondaryActionsMarkup ? 'equalSpacing' : 'trailing';
    return createElement(
        'div',
        { className: styles$41.PageActions },
        createElement(
            Stack$1,
            { distribution: distribution, spacing: 'tight' },
            secondaryActionsMarkup,
            primaryActionMarkup
        )
    );
}

var styles$42 = {
  "Thumbnail": "p_xs",
  "sizeSmall": "p_d6",
  "sizeMedium": "p_t0",
  "sizeLarge": "p_ma",
  "Image": "p_jn",
};

function Thumbnail$1({ source, alt, size = 'medium' }) {
    const className = classNames(styles$42.Thumbnail, size && styles$42[variationName('size', size)]);
    return createElement(
        'span',
        { className: className },
        createElement(Image$1, { alt: alt, source: source, className: styles$42.Image })
    );
}

var styles$43 = {
  "ResourceList": "p_zm",
  "ItemWrapper": "p_te",
  "Item": "p_as",
  "Item-persistActions": "p_m7",
  "Actions": "p_ka",
  "Item-focused": "p_k3",
  "AttributeThree": "p_ww",
  "Item-link": "p_j8",
  "Item-mediaAvatar": "p_l7",
  "Item-sizeSmall": "p_zk",
  "Item-sizeMedium": "p_yq",
  "Item-sizeLarge": "p_eu",
  "Item-mediaThumbnail": "p_z6",
  "Media": "p_x4",
  "Container": "p_vh",
  "Content": "p_jm",
  "Attributes": "p_b0",
  "AttributeOne": "p_gj",
  "AttributeTwo": "p_hy",
  "Badge": "p_d1",
  "Disclosure": "p_z0",
  "ExceptionList": "p_jd",
  "ExceptionItem": "p_zw",
  "ExceptionItem-statusWarning": "p_t7",
  "Title": "p_s8",
  "ExceptionItem-statusCritical": "p_cg",
  "Description": "p_vp",
  "Link": "p_s6",
};

const getUniqueID$5 = createUniqueIDFactory('ResourceListItem');
class Item$5 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            actionsMenuVisible: false,
            focused: false
        };
        this.node = null;
        this.id = getUniqueID$5();
    }
    render() {
        const { url, media, attributeOne, attributeTwo, attributeThree, badges, exceptions, actions, persistActions = false } = this.props;
        const { actionsMenuVisible, focused } = this.state;
        const attributeTwoMarkup = attributeTwo ? createElement(
            'div',
            { className: styles$43.AttributeTwo },
            attributeTwo
        ) : null;
        const badgeMarkup = badges ? createElement(
            'div',
            { className: styles$43.Badge },
            badges.map(renderBadge)
        ) : null;
        const attributeThreeMarkup = attributeThree ? createElement(
            'div',
            { className: styles$43.AttributeThree },
            attributeThree
        ) : null;
        const exceptionsMarkup = exceptions ? createElement(
            'ul',
            { className: styles$43.ExceptionList },
            exceptions.map(renderException)
        ) : null;
        let mediaSize = null;
        let mediaType = null;
        let mediaMarkup = null;
        if (media) {
            if (isElementOfType(media, Avatar$1)) {
                mediaSize = media.props.size || 'medium';
                mediaType = 'avatar';
            }
            if (isElementOfType(media, Thumbnail$1)) {
                mediaSize = media.props.size || 'medium';
                mediaType = 'thumbnail';
            }
            mediaMarkup = createElement(
                'div',
                { className: styles$43.Media },
                media
            );
        }
        const className = classNames(styles$43.Item, url && styles$43['Item-link'], focused && styles$43['Item-focused'], persistActions && styles$43['Item-persistActions'], mediaType && styles$43[variationName('Item-media', mediaType)], mediaSize && styles$43[variationName('Item-size', mediaSize)]);
        let actionsMarkup = null;
        let disclosureMarkup = null;
        if (actions) {
            if (persistActions) {
                actionsMarkup = createElement(
                    'div',
                    { className: styles$43.Actions },
                    createElement(
                        ButtonGroup$1,
                        null,
                        buttonsFrom(actions, { size: 'slim', plain: true })
                    )
                );
                disclosureMarkup = createElement(
                    'div',
                    { className: styles$43.Disclosure },
                    createElement(
                        Popover$2,
                        { activator: createElement(Button$1, { 'aria-label': 'Actions dropdown', onClick: this.handleClick, plain: true, icon: 'horizontalDots' }), onClose: this.handleCloseRequest, active: actionsMenuVisible },
                        createElement(ActionList$1, { items: actions })
                    )
                );
            } else {
                actionsMarkup = createElement(
                    'div',
                    { className: styles$43.Actions },
                    createElement(
                        ButtonGroup$1,
                        { segmented: true },
                        buttonsFrom(actions, { size: 'slim' })
                    )
                );
            }
        }
        const containerMarkup = createElement(
            'div',
            { className: styles$43.Container, id: this.id },
            mediaMarkup,
            createElement(
                'div',
                { className: styles$43.Content },
                createElement(
                    'div',
                    { className: styles$43.Attributes },
                    createElement(
                        'p',
                        { className: styles$43.AttributeOne },
                        attributeOne
                    ),
                    attributeTwoMarkup,
                    badgeMarkup,
                    attributeThreeMarkup
                ),
                exceptionsMarkup
            ),
            actionsMarkup,
            disclosureMarkup
        );
        return url ? createElement(
            'div',
            { ref: this.setNode, className: className, onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.mouseEnter, onMouseLeave: this.mouseLeave },
            createElement(UnstyledLink$1, { 'aria-describedby': this.id, className: styles$43.Link, url: url }),
            containerMarkup
        ) : createElement(
            'div',
            { ref: this.setNode, className: className, onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.mouseEnter, onMouseLeave: this.mouseLeave },
            containerMarkup
        );
    }
    setNode(node) {
        this.node = node;
    }
    handleFocus() {
        this.setState({ focused: true });
    }
    handleBlur(event) {
        if (this.node == null || !this.node.contains(event.relatedTarget)) {
            this.setState({ focused: false });
        }
    }
    mouseEnter() {
        this.setState({ focused: true });
    }
    mouseLeave() {
        this.setState({ focused: false });
    }
    handleClick() {
        this.setState({ actionsMenuVisible: true });
    }
    handleCloseRequest() {
        this.setState({ actionsMenuVisible: false });
    }
}
__decorate([autobind], Item$5.prototype, "setNode", null);
__decorate([autobind], Item$5.prototype, "handleFocus", null);
__decorate([autobind], Item$5.prototype, "handleBlur", null);
__decorate([autobind], Item$5.prototype, "mouseEnter", null);
__decorate([autobind], Item$5.prototype, "mouseLeave", null);
__decorate([autobind], Item$5.prototype, "handleClick", null);
__decorate([autobind], Item$5.prototype, "handleCloseRequest", null);
function renderBadge(badge) {
    return createElement(
        Badge$1,
        { key: badge.content, status: badge.status },
        badge.content
    );
}
function renderException(exception, index) {
    const { status, title, description } = exception;
    const className = classNames(styles$43.ExceptionItem, status && styles$43[variationName('ExceptionItem-status', status)]);
    const titleMarkup = title != null ? createElement(
        'div',
        { className: styles$43.Title },
        title
    ) : null;
    const descriptionMarkup = description != null ? createElement(
        'div',
        { className: styles$43.Description },
        description
    ) : null;
    return createElement(
        'li',
        { key: index, className: className },
        titleMarkup,
        descriptionMarkup
    );
}

class ResourceList$1 extends PureComponent {
    render() {
        const { items } = this.props;
        return createElement(
            'ul',
            { className: styles$43.ResourceList },
            items.map(this.renderItem)
        );
    }
    renderItem(item, index) {
        const { renderItem } = this.props;
        return createElement(
            'li',
            { key: index, className: styles$43.ItemWrapper },
            renderItem(item, index)
        );
    }
}
ResourceList$1.Item = Item$5;
__decorate([autobind], ResourceList$1.prototype, "renderItem", null);

var styles$44 = {
  "hidden": "p_kj",
  "LabelWrapper": "p_k0",
  "HelpText": "p_fi",
  "Error": "p_dv",
  "ErrorIcon": "p_n8",
};

function Labelled$1(_a) {
    var { id, label, error, children, labelHidden, helpText } = _a,
        rest = __rest(_a, ["id", "label", "error", "children", "labelHidden", "helpText"]);
    const className = classNames(labelHidden && styles$44.hidden);
    const helpTextMarkup = helpText ? createElement(
        'div',
        { className: styles$44.HelpText, id: helpTextID$1(id) },
        helpText
    ) : null;
    const errorMarkup = typeof error === 'string' ? createElement(
        'div',
        { id: errorID$1(id), className: styles$44.Error },
        createElement(
            'div',
            { className: styles$44.ErrorIcon },
            createElement(Icon$1, { source: 'alert' })
        ),
        error
    ) : null;
    const labelMarkup = label ? createElement(
        'div',
        { className: styles$44.LabelWrapper },
        createElement(
            Label$1,
            Object.assign({ id: id }, rest, { hidden: false }),
            label
        )
    ) : null;
    return createElement(
        'div',
        { className: className },
        labelMarkup,
        children,
        errorMarkup,
        helpTextMarkup
    );
}
function errorID$1(id) {
    return `${id}Error`;
}
function helpTextID$1(id) {
    return `${id}HelpText`;
}

var styles$45 = {
  "Select": "p_vd",
  "disabled": "p_c9",
  "Backdrop": "p_qm",
  "Icon": "p_ml",
  "error": "p_n1",
  "Input": "p_jo",
  "placeholder": "p_e2",
};

const PLACEHOLDER_VALUE = '__placeholder__';
const getUniqueID$6 = createUniqueIDFactory('Select');
function Select$1({ id = getUniqueID$6(), name, groups, options, labelHidden, labelAction, helpText, label, error, value, placeholder, disabled, onChange, onFocus, onBlur }) {
    let optionsMarkup;
    if (options != null) {
        optionsMarkup = options.map(renderOption);
    } else if (groups != null) {
        optionsMarkup = groups.map(renderGroup);
    }
    const isPlaceholder = value == null && placeholder != null;
    const className = classNames(styles$45.Select, error && styles$45.error, disabled && styles$45.disabled, isPlaceholder && styles$45.placeholder);
    const handleChange = onChange ? event => onChange(event.currentTarget.value, id) : undefined;
    const describedBy = [];
    if (helpText) {
        describedBy.push(helpTextID$1(id));
    }
    if (error && typeof error === 'string') {
        describedBy.push(errorID$1(id));
    }
    const placeholderOption = isPlaceholder ? createElement('option', { label: placeholder, value: PLACEHOLDER_VALUE, disabled: true, hidden: true }) : null;
    // When we have no onChange, React will complain about providing a `value`
    // (and vice versa for `defaultValue`)
    const defaultValue = onChange ? undefined : value || PLACEHOLDER_VALUE;
    const finalValue = onChange ? value || PLACEHOLDER_VALUE : undefined;
    return createElement(
        Labelled$1,
        { id: id, label: label, error: error, action: labelAction, labelHidden: labelHidden, helpText: helpText },
        createElement(
            'div',
            { className: className },
            createElement(
                'select',
                { id: id, name: name, defaultValue: defaultValue, value: finalValue, className: styles$45.Input, disabled: disabled, onFocus: onFocus, onBlur: onBlur, onChange: handleChange, 'aria-invalid': Boolean(error), 'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined },
                placeholderOption,
                optionsMarkup
            ),
            createElement(
                'div',
                { className: styles$45.Icon },
                createElement(Icon$1, { source: 'arrowUpDown' })
            ),
            createElement('div', { className: styles$45.Backdrop })
        )
    );
}
function renderOption(option) {
    if (typeof option === 'string') {
        return createElement(
            'option',
            { key: option, value: option },
            option
        );
    } else {
        return createElement(
            'option',
            { key: option.value, value: option.value, disabled: option.disabled },
            option.label
        );
    }
}
function renderGroup(groupOrOption) {
    if (groupOrOption.hasOwnProperty('title')) {
        const { title, options } = groupOrOption;
        return createElement(
            'optgroup',
            { label: title, key: title },
            options.map(renderOption)
        );
    }
    return renderOption(groupOrOption);
}

function SettingToggle$1({ enabled, action, children }) {
    const actionMarkup = action ? buttonFrom(action, { primary: !enabled }) : null;
    return createElement(
        Card$1,
        { sectioned: true },
        createElement(
            SettingAction$1,
            { action: actionMarkup },
            children
        )
    );
}

var styles$46 = {
  "Tabs": "p_i4",
  "fitted": "p_xl",
  "TabContainer": "p_bj",
  "Tab": "p_al",
  "Title": "p_gn",
  "fillSpace": "p_b5",
  "Tab-selected": "p_y6",
  "Panel": "p_j7",
  "List": "p_tz",
  "Item": "p_yn",
  "DisclosureTab": "p_ac",
  "DisclosureTab-visible": "p_w0",
  "DisclosureActivator": "p_zt",
  "TabMeasurer": "p_km",
};

class Item$6 extends PureComponent {
    constructor() {
        super(...arguments);
        this.focusedNode = null;
    }
    componentDidMount() {
        const { focusedNode } = this;
        const { focused } = this.props;
        if (focusedNode && focused) {
            focusedNode.focus();
        }
    }
    componentDidUpdate() {
        const { focusedNode } = this;
        const { focused } = this.props;
        if (focusedNode && focused) {
            focusedNode.focus();
        }
    }
    render() {
        const { id, children, panelID, onClick = noop, accessibilityLabel } = this.props;
        const className = classNames(styles$46.Item);
        return createElement(
            'li',
            { role: 'presentation' },
            createElement(
                'button',
                { id: id, ref: this.setFocusedNode, onClick: onClick, className: className, 'aria-controls': panelID, 'aria-selected': false, 'aria-label': accessibilityLabel },
                children
            )
        );
    }
    setFocusedNode(node) {
        this.focusedNode = node;
    }
}
__decorate([autobind], Item$6.prototype, "setFocusedNode", null);

class List$1 extends PureComponent {
    render() {
        const { focusIndex, disclosureTabs, onClick = noop } = this.props;
        const tabs = disclosureTabs.map(({ id, panelID, title, accessibilityLabel }, index) => {
            return createElement(
                Item$6,
                { key: id, id: id, panelID: panelID, focused: index === focusIndex, accessibilityLabel: accessibilityLabel, onClick: onClick.bind(null, id) },
                title
            );
        });
        return createElement(
            'ul',
            { className: styles$46.List, onKeyDown: handleKeyDown$2, onKeyUp: this.handleKeypress },
            tabs
        );
    }
    handleKeypress(event) {
        const { onKeyPress = noop } = this.props;
        onKeyPress(event);
    }
}
__decorate([autobind], List$1.prototype, "handleKeypress", null);
function handleKeyDown$2(event) {
    const { key } = event;
    if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
    }
}

class Tab extends PureComponent {
    constructor() {
        super(...arguments);
        this.node = null;
    }
    // A tab can start selected when it is moved from the disclosure dropdown
    // into the main list, so we need to send focus from the tab to the panel
    // on mount and update
    componentDidMount() {
        const { id, measuring, selected, panelID, focused } = this.props;
        if (measuring) {
            return;
        }
        // Because of timing issues with the render, we may still have the old,
        // in-disclosure version of the tab that has focus. Check for this
        // as a second indicator of focus
        const itemHadFocus = focused || document.activeElement && document.activeElement.id === id;
        // If we just check for selected, the panel for the active tab will
        // be focused on page load, which we don't want
        if (itemHadFocus && selected && panelID != null) {
            focusPanelID(panelID);
        }
    }
    componentDidUpdate(previousProps) {
        const { selected: wasSelected } = previousProps;
        const { focused, measuring, selected, panelID } = this.props;
        if (measuring) {
            return;
        }
        if (selected && !wasSelected && panelID != null) {
            focusPanelID(panelID);
        } else if (focused && this.node != null) {
            focusFirstFocusableNode(this.node);
        }
    }
    render() {
        const { id, focused, siblingTabHasFocus, children, onClick, selected, url, panelID, measuring, accessibilityLabel } = this.props;
        const handleClick = onClick && onClick.bind(null, id);
        const className = classNames(styles$46.Tab, selected && styles$46['Tab-selected']);
        let tabIndex;
        if (selected && !siblingTabHasFocus && !measuring) {
            tabIndex = 0;
        } else if (focused && !measuring) {
            tabIndex = 0;
        } else {
            tabIndex = -1;
        }
        const markup = url ? createElement(
            UnstyledLink$1,
            { id: id, url: url, role: 'tab', tabIndex: tabIndex, onClick: handleClick, className: className, 'aria-selected': selected, 'aria-controls': panelID, 'aria-label': accessibilityLabel, onMouseUp: handleMouseUpByBlurring },
            createElement(
                'span',
                { className: styles$46.Title },
                children
            )
        ) : createElement(
            'button',
            { id: id, role: 'tab', tabIndex: tabIndex, className: className, onClick: handleClick, 'aria-selected': selected, 'aria-controls': panelID, 'aria-label': accessibilityLabel, onMouseUp: handleMouseUpByBlurring },
            createElement(
                'span',
                { className: styles$46.Title },
                children
            )
        );
        return createElement(
            'li',
            { role: 'presentation', className: styles$46.TabContainer, ref: this.setNode },
            markup
        );
    }
    setNode(node) {
        this.node = node;
    }
}
__decorate([autobind], Tab.prototype, "setNode", null);
function focusPanelID(panelID) {
    const panel = document.getElementById(panelID);
    if (panel) {
        panel.focus();
    }
}

class TabMeasurer extends PureComponent {
    constructor() {
        super(...arguments);
        this.containerNode = null;
    }
    componentDidMount() {
        this.handleMeasurement();
        if (process.env.NODE_ENV === 'development') {
            // We need to defer the calculation in development so the
            // styles have time to be injected.
            setTimeout(this.handleMeasurement, 0);
        }
    }
    componentDidUpdate(prevProps) {
        if (prevProps.tabs !== this.props.tabs) {
            this.handleMeasurement();
        }
    }
    render() {
        const { selected, tabs, activator, tabToFocus, siblingTabHasFocus } = this.props;
        const tabsMarkup = tabs.map((tab, index) => {
            return createElement(
                Tab,
                { measuring: true, key: `${index}${tab.id}Hidden`, id: `${tab.id}Measurer`, siblingTabHasFocus: siblingTabHasFocus, focused: index === tabToFocus, selected: index === selected, onClick: noop, url: tab.url },
                tab.title
            );
        });
        const classname = classNames(styles$46.Tabs, styles$46.TabMeasurer);
        return createElement(
            'div',
            { className: classname, ref: this.setContainerNode },
            createElement(EventListener$1, { event: 'resize', handler: this.handleMeasurement }),
            tabsMarkup,
            activator
        );
    }
    setContainerNode(node) {
        this.containerNode = node;
    }
    handleMeasurement() {
        if (this.containerNode == null) {
            return;
        }
        const { handleMeasurement } = this.props;
        const containerWidth = this.containerNode.offsetWidth;
        const hiddenTabNodes = findDOMNode(this).children;
        const hiddenTabNodesArray = [].slice.call(hiddenTabNodes);
        const hiddenTabWidths = hiddenTabNodesArray.map(node => {
            return node.getBoundingClientRect().width;
        });
        const disclosureWidth = hiddenTabWidths.pop();
        handleMeasurement({
            containerWidth,
            disclosureWidth,
            hiddenTabWidths
        });
    }
}
__decorate([autobind], TabMeasurer.prototype, "setContainerNode", null);
__decorate([autobind], TabMeasurer.prototype, "handleMeasurement", null);

function Panel({ id, tabID, children }) {
  return createElement(
    'div',
    { className: styles$46.Panel, id: id, role: 'tabpanel', 'aria-labelledby': tabID, tabIndex: -1 },
    children
  );
}

class Tabs$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            disclosureWidth: 0,
            containerWidth: Infinity,
            tabWidths: [],
            visibleTabs: [],
            hiddenTabs: [],
            showDisclosure: false,
            tabToFocus: -1
        };
    }
    componentWillReceiveProps(nextProps) {
        const { selected } = this.props;
        const { disclosureWidth, tabWidths, containerWidth, tabToFocus } = this.state;
        const { visibleTabs, hiddenTabs } = getVisibleAndHiddenTabIndices(nextProps.tabs, nextProps.selected, disclosureWidth, tabWidths, containerWidth);
        this.setState({
            visibleTabs,
            hiddenTabs,
            tabToFocus: selected === nextProps.selected ? -1 : tabToFocus,
            showDisclosure: false
        });
    }
    render() {
        const { tabs, selected, fitted, children } = this.props;
        const { tabToFocus, visibleTabs, hiddenTabs, showDisclosure } = this.state;
        const disclosureTabs = hiddenTabs.map(tabIndex => tabs[tabIndex]);
        const panelMarkup = children ? createElement(
            Panel,
            { id: tabs[selected].panelID || `${tabs[selected].id}-panel`, tabID: tabs[selected].id },
            children
        ) : null;
        const tabsMarkup = visibleTabs.sort((tabA, tabB) => tabA - tabB).map(tabIndex => this.renderTabMarkup(tabs[tabIndex], tabIndex));
        const disclosureActivatorVisible = visibleTabs.length < tabs.length;
        const classname = classNames(styles$46.Tabs, fitted && styles$46.fitted, disclosureActivatorVisible && styles$46.fillSpace);
        const disclosureTabClassName = classNames(styles$46.DisclosureTab, disclosureActivatorVisible && styles$46['DisclosureTab-visible']);
        const activator = createElement(
            'button',
            { tabIndex: -1, className: styles$46.DisclosureActivator, onClick: this.handleDisclosureActivatorClick },
            createElement(Icon$1, { source: 'horizontalDots' })
        );
        return createElement(
            'div',
            null,
            createElement(
                'ul',
                { role: 'tablist', className: classname, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: handleKeyDown$1, onKeyUp: this.handleKeyPress },
                tabsMarkup,
                createElement(
                    'li',
                    { role: 'presentation', className: disclosureTabClassName },
                    createElement(
                        Popover$2,
                        { preventAutofocus: true, preferredPosition: 'below', activator: activator, active: disclosureActivatorVisible && showDisclosure, onClose: this.handleClose },
                        createElement(List$1, { focusIndex: hiddenTabs.indexOf(tabToFocus), disclosureTabs: disclosureTabs, onClick: this.handleTabClick, onKeyPress: this.handleKeyPress })
                    )
                )
            ),
            createElement(TabMeasurer, { tabToFocus: tabToFocus, activator: activator, selected: selected, tabs: tabs, siblingTabHasFocus: tabToFocus > -1, handleMeasurement: this.handleMeasurement }),
            panelMarkup
        );
    }
    handleKeyPress(event) {
        const { tabToFocus, visibleTabs, hiddenTabs } = this.state;
        const tabsArrayInOrder = visibleTabs.concat(hiddenTabs);
        const key = event.key;
        let newFocus = tabsArrayInOrder.indexOf(tabToFocus);
        if (key === 'ArrowRight' || key === 'ArrowDown') {
            newFocus += 1;
            if (newFocus === tabsArrayInOrder.length) {
                newFocus = 0;
            }
        }
        if (key === 'ArrowLeft' || key === 'ArrowUp') {
            newFocus -= 1;
            if (newFocus === -1) {
                newFocus = tabsArrayInOrder.length - 1;
            }
        }
        this.setState({
            showDisclosure: hiddenTabs.indexOf(tabsArrayInOrder[newFocus]) > -1,
            tabToFocus: tabsArrayInOrder[newFocus]
        });
    }
    renderTabMarkup(tab, index) {
        const { selected } = this.props;
        const { tabToFocus } = this.state;
        return createElement(
            Tab,
            { key: `${index}-${tab.id}`, id: tab.id, siblingTabHasFocus: tabToFocus > -1, focused: index === tabToFocus, selected: index === selected, onClick: this.handleTabClick, panelID: tab.panelID || `${tab.id}-panel`, accessibilityLabel: tab.accessibilityLabel, url: tab.url },
            tab.title
        );
    }
    handleFocus(event) {
        const { selected, tabs } = this.props;
        // If we are explicitly focusing one of the non-selected tabs, use it
        // move the focus to it
        const target = event.target;
        if (target.classList.contains(styles$46.Tab) || target.classList.contains(styles$46.Item)) {
            let tabToFocus = -1;
            tabs.every((tab, index) => {
                if (tab.id === target.id) {
                    tabToFocus = index;
                    return false;
                }
                return true;
            });
            this.setState({ tabToFocus });
            return;
        }
        if (target.classList.contains(styles$46.DisclosureActivator)) {
            return;
        }
        // If we are coming in from somewhere other than another tab, focus the
        // selected tab, and the focus (click) is not on the disclosure activator,
        // focus the selected tab
        if (!event.relatedTarget) {
            this.setState({ tabToFocus: selected });
            return;
        }
        const relatedTarget = event.relatedTarget;
        if (!relatedTarget.classList.contains(styles$46.Tab) && !relatedTarget.classList.contains(styles$46.Item) && !relatedTarget.classList.contains(styles$46.DisclosureActivator)) {
            this.setState({ tabToFocus: selected });
        }
    }
    handleBlur(event) {
        // If we blur and the target is not another tab, forget the focus position
        if (event.relatedTarget == null) {
            this.setState({ tabToFocus: -1 });
            return;
        }
        const target = event.relatedTarget;
        // If we are going to anywhere other than another tab, lose the last focused tab
        if (!target.classList.contains(styles$46.Tab) && !target.classList.contains(styles$46.Item)) {
            this.setState({ tabToFocus: -1 });
        }
    }
    handleDisclosureActivatorClick() {
        this.setState(({ showDisclosure }) => ({ showDisclosure: !showDisclosure }));
    }
    handleClose() {
        this.setState({
            showDisclosure: false
        });
    }
    handleMeasurement(measurements) {
        const { tabs, selected } = this.props;
        const { tabToFocus } = this.state;
        const { hiddenTabWidths: tabWidths, containerWidth, disclosureWidth } = measurements;
        const { visibleTabs, hiddenTabs } = getVisibleAndHiddenTabIndices(tabs, selected, disclosureWidth, tabWidths, containerWidth);
        this.setState({
            tabToFocus: tabToFocus === -1 ? -1 : selected,
            visibleTabs,
            hiddenTabs,
            disclosureWidth,
            containerWidth,
            tabWidths
        });
    }
    handleTabClick(id) {
        const { tabs, onSelect = noop } = this.props;
        const tab = tabs.find(aTab => aTab.id === id);
        if (tab == null) {
            return;
        }
        const selectedIndex = tabs.indexOf(tab);
        onSelect(selectedIndex);
    }
}
Tabs$1.Panel = Panel;
__decorate([autobind], Tabs$1.prototype, "handleKeyPress", null);
__decorate([autobind], Tabs$1.prototype, "renderTabMarkup", null);
__decorate([autobind], Tabs$1.prototype, "handleFocus", null);
__decorate([autobind], Tabs$1.prototype, "handleBlur", null);
__decorate([autobind], Tabs$1.prototype, "handleDisclosureActivatorClick", null);
__decorate([autobind], Tabs$1.prototype, "handleClose", null);
__decorate([autobind], Tabs$1.prototype, "handleMeasurement", null);
__decorate([autobind], Tabs$1.prototype, "handleTabClick", null);
function handleKeyDown$1(event) {
    const { key } = event;
    if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
    }
}
function getVisibleAndHiddenTabIndices(tabs, selected, disclosureWidth, tabWidths, containerWidth) {
    const sumTabWidths = tabWidths.reduce((sum, width) => sum + width, 0);
    const arrayOfTabIndices = tabs.map((_, index) => {
        return index;
    });
    const visibleTabs = [];
    const hiddenTabs = [];
    if (containerWidth > sumTabWidths) {
        visibleTabs.push(...arrayOfTabIndices);
    } else {
        visibleTabs.push(selected);
        let newTabWidth = tabWidths[selected];
        arrayOfTabIndices.forEach(index => {
            if (index !== selected) {
                if (newTabWidth + tabWidths[index] > containerWidth - disclosureWidth) {
                    hiddenTabs.push(index);
                    return;
                }
                visibleTabs.push(index);
                newTabWidth += tabWidths[index];
            }
        });
    }
    return {
        visibleTabs,
        hiddenTabs
    };
}

var styles$47 = {
  "Tag": "p_ru",
  "Button": "p_xc",
};

function Tag$1({ children, onRemove }) {
  return createElement(
    'span',
    { className: styles$47.Tag },
    createElement(
      'span',
      null,
      children
    ),
    createElement(
      'button',
      { 'aria-label': 'Remove', className: styles$47.Button, onClick: onRemove, onMouseUp: handleMouseUpByBlurring },
      createElement(Icon$1, { source: 'cancelSmall' })
    )
  );
}

var styles$48 = {
  "Connected": "p_l6",
  "Item": "p_sg",
  "Item-primary": "p_dr",
  "Item-connection": "p_em",
  "Item-focused": "p_ys",
};

var Position;
(function (Position) {
    Position[Position["Left"] = 0] = "Left";
    Position[Position["Primary"] = 1] = "Primary";
    Position[Position["Right"] = 2] = "Right";
})(Position || (Position = {}));
class Item$7 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = { focused: false };
    }
    render() {
        const { focused } = this.state;
        const { children, position } = this.props;
        const className = classNames(styles$48.Item, focused && styles$48['Item-focused'], position === Position.Primary ? styles$48['Item-primary'] : styles$48['Item-connection']);
        return createElement(
            'div',
            { onBlur: this.handleBlur, onFocus: this.handleFocus, className: className },
            children
        );
    }
    handleBlur() {
        this.setState({ focused: false });
    }
    handleFocus() {
        this.setState({ focused: true });
    }
}
__decorate([autobind], Item$7.prototype, "handleBlur", null);
__decorate([autobind], Item$7.prototype, "handleFocus", null);

function Connected$1({ children, left, right }) {
    if (left == null && right == null) {
        return Children.only(children);
    }
    const leftConnectionMarkup = left ? createElement(
        Item$7,
        { position: Position.Left },
        left
    ) : null;
    const rightConnectionMarkup = right ? createElement(
        Item$7,
        { position: Position.Right },
        right
    ) : null;
    return createElement(
        'div',
        { className: styles$48.Connected },
        leftConnectionMarkup,
        createElement(
            Item$7,
            { position: Position.Primary },
            children
        ),
        rightConnectionMarkup
    );
}

var styles$49 = {
  "TextField": "p_np",
  "multiline": "p_bc",
  "Input": "p_ul",
  "hasValue": "p_ks",
  "error": "p_iv",
  "Backdrop": "p_ef",
  "readOnly": "p_ps",
  "disabled": "p_qq",
  "Prefix": "p_hh",
  "Suffix": "p_wh",
  "Spinner": "p_a2",
  "SpinnerIcon": "p_c8",
  "Resizer": "p_dn",
  "DummyInput": "p_c1",
  "Segment": "p_ug",
};

class Resizer extends PureComponent {
    constructor() {
        super(...arguments);
        this.contentNode = null;
        this.minimumLinesNode = null;
    }
    componentDidMount() {
        this.handleHeightCheck();
        if (process.env.NODE_ENV === 'development') {
            // We need to defer the calculation in development so the
            // styles have time to be injected.
            setTimeout(this.handleHeightCheck, 0);
        }
    }
    componentDidUpdate() {
        this.handleHeightCheck();
    }
    render() {
        const { contents, minimumLines } = this.props;
        const minimumLinesMarkup = minimumLines ? createElement('div', { ref: this.setMinimumLinesNode, className: styles$49.DummyInput, dangerouslySetInnerHTML: { __html: getContentsForMinimumLines(minimumLines) } }) : null;
        return createElement(
            'div',
            { 'aria-hidden': true, className: styles$49.Resizer },
            createElement(EventListener$1, { event: 'resize', handler: this.handleHeightCheck }),
            createElement('div', { ref: this.setContentNode, className: styles$49.DummyInput, dangerouslySetInnerHTML: { __html: getFinalContents(contents) } }),
            minimumLinesMarkup
        );
    }
    handleHeightCheck() {
        if (this.contentNode == null || this.minimumLinesNode == null) {
            return;
        }
        const contentHeight = this.contentNode.offsetHeight;
        const minimumHeight = this.setMinimumLinesNode ? this.minimumLinesNode.offsetHeight : 0;
        const newHeight = Math.max(contentHeight, minimumHeight);
        const { currentHeight, onHeightChange } = this.props;
        if (newHeight !== currentHeight) {
            onHeightChange(newHeight);
        }
    }
    setContentNode(node) {
        this.contentNode = node;
    }
    setMinimumLinesNode(node) {
        this.minimumLinesNode = node;
    }
}
__decorate([autobind], Resizer.prototype, "handleHeightCheck", null);
__decorate([autobind], Resizer.prototype, "setContentNode", null);
__decorate([autobind], Resizer.prototype, "setMinimumLinesNode", null);
const ENTITIES_TO_REPLACE = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '\n': '<br>'
};
const REPLACE_REGEX = /[\n&<>]/g;
function replaceEntity(entity) {
    return ENTITIES_TO_REPLACE[entity] || entity;
}
function getContentsForMinimumLines(minimumLines) {
    let content = '';
    for (let line = 0; line < minimumLines; line++) {
        content += '<br>';
    }
    return content;
}
function getFinalContents(contents) {
    return contents ? `${contents.replace(REPLACE_REGEX, replaceEntity)}<br>` : '<br>';
}

function Spinner({ onChange, onClick }) {
  function handleStep(step) {
    return () => onChange(step);
  }
  return createElement(
    'div',
    { className: styles$49.Spinner, onClick: onClick, 'aria-hidden': true },
    createElement(
      'div',
      { role: 'button', className: styles$49.Segment, tabIndex: -1, onClick: handleStep(1) },
      createElement(
        'div',
        { className: styles$49.SpinnerIcon },
        createElement(Icon$1, { source: 'caretUp' })
      )
    ),
    createElement(
      'div',
      { role: 'button', className: styles$49.Segment, tabIndex: -1, onClick: handleStep(-1) },
      createElement(
        'div',
        { className: styles$49.SpinnerIcon },
        createElement(Icon$1, { source: 'caretDown' })
      )
    )
  );
}

const getUniqueID$7 = createUniqueIDFactory('TextField');
class TextField$1 extends PureComponent {
    constructor(props) {
        super();
        this.state = {
            height: null,
            id: props.id || getUniqueID$7()
        };
    }
    componentWillReceiveProps(newProps) {
        this.setState({
            id: newProps.id || this.state.id
        });
    }
    render() {
        const _a = this.props,
              { id = getUniqueID$7(), value = '', placeholder, disabled, readOnly, autoFocus, type, name, error, multiline, connectedRight, connectedLeft, label, labelAction, labelHidden, helpText, prefix, suffix, onFocus, onBlur, autoComplete } = _a,
              rest = __rest(_a, ["id", "value", "placeholder", "disabled", "readOnly", "autoFocus", "type", "name", "error", "multiline", "connectedRight", "connectedLeft", "label", "labelAction", "labelHidden", "helpText", "prefix", "suffix", "onFocus", "onBlur", "autoComplete"]);
        const { height } = this.state;
        const className = classNames(styles$49.TextField, Boolean(value) && styles$49.hasValue, disabled && styles$49.disabled, readOnly && styles$49.readOnly, error && styles$49.error, multiline && styles$49.multiline);
        const prefixMarkup = prefix ? createElement(
            'div',
            { onClick: this.handleInputFocus, className: styles$49.Prefix, id: `${id}Prefix` },
            prefix
        ) : null;
        const suffixMarkup = suffix ? createElement(
            'div',
            { onClick: this.handleInputFocus, className: styles$49.Suffix, id: `${id}Suffix` },
            suffix
        ) : null;
        const spinnerMarkup = type === 'number' && !disabled ? createElement(Spinner, { onClick: this.handleInputFocus, onChange: this.handleNumberChange }) : null;
        const style = multiline && height ? { height } : null;
        const resizer = multiline != null ? createElement(Resizer, { contents: value || placeholder, currentHeight: height, minimumLines: typeof multiline === 'number' ? multiline : 1, onHeightChange: this.handleExpandingResize }) : null;
        const describedBy = [];
        if (error && typeof error === 'string') {
            describedBy.push(errorID$1(id));
        }
        if (helpText) {
            describedBy.push(helpTextID$1(id));
        }
        const labelledBy = [labelID(id)];
        if (prefix) {
            labelledBy.push(`${id}Prefix`);
        }
        if (suffix) {
            labelledBy.push(`${id}Suffix`);
        }
        const input = createElement(multiline ? 'textarea' : 'input', Object.assign({}, rest, { name,
            id,
            type,
            disabled,
            readOnly,
            autoFocus,
            value,
            placeholder,
            onFocus,
            onBlur,
            style, autoComplete: normalizeAutoComplete(autoComplete), className: styles$49.Input, onChange: this.handleChange, ref: this.setInput, 'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined, 'aria-labelledby': labelledBy.join(' '), 'aria-invalid': Boolean(error) }));
        return createElement(
            Labelled$1,
            { label: label, id: id, error: error, action: labelAction, labelHidden: labelHidden, helpText: helpText },
            createElement(
                Connected$1,
                { left: connectedLeft, right: connectedRight },
                createElement(
                    'div',
                    { className: className },
                    prefixMarkup,
                    input,
                    suffixMarkup,
                    spinnerMarkup,
                    createElement('div', { className: styles$49.Backdrop }),
                    resizer
                )
            )
        );
    }
    setInput(input) {
        this.input = input;
    }
    handleNumberChange(steps) {
        const { onChange, value, step = 1, min = -Infinity, max = Infinity } = this.props;
        if (onChange == null) {
            return;
        }
        const numericValue = value ? parseFloat(value) : 0;
        if (isNaN(numericValue)) {
            return;
        }
        const newValue = Math.min(max, Math.max(numericValue + steps * step, min));
        onChange(String(newValue), this.state.id);
    }
    handleExpandingResize(height) {
        this.setState({ height });
    }
    handleChange(event) {
        const { onChange } = this.props;
        if (onChange == null) {
            return;
        }
        onChange(event.currentTarget.value, this.state.id);
    }
    handleInputFocus() {
        this.input.focus();
    }
}
__decorate([autobind], TextField$1.prototype, "setInput", null);
__decorate([autobind], TextField$1.prototype, "handleNumberChange", null);
__decorate([autobind], TextField$1.prototype, "handleExpandingResize", null);
__decorate([autobind], TextField$1.prototype, "handleChange", null);
__decorate([autobind], TextField$1.prototype, "handleInputFocus", null);
function normalizeAutoComplete(autoComplete) {
    if (autoComplete == null) {
        return autoComplete;
    }
    return autoComplete ? 'on' : 'off';
}

var styles$50 = {
  "Tooltip": "p_hq",
  "measuring": "p_un",
  "positionedAbove": "p_rd",
  "Tip": "p_r8",
  "light": "p_mc",
  "Wrapper": "p_i6",
  "Content": "p_xv",
  "Label": "p_mp",
};

class TooltipOverlay extends PureComponent {
    render() {
        const markup = this.props.active ? this.renderOverlay() : null;
        return markup;
    }
    renderOverlay() {
        const { active, activator, preferredPosition = 'below' } = this.props;
        return createElement(PositionedOverlay$1, { active: active, activator: activator, preferredPosition: preferredPosition, render: this.renderTooltip });
    }
    renderTooltip(overlayDetails) {
        const { left, measuring, desiredHeight, positioning, activatorRect } = overlayDetails;
        const { id, children, light } = this.props;
        const tipStyle = calculateTipPosition(activatorRect.center.x, left);
        const containerClassName = classNames(styles$50.Tooltip, light && styles$50.light, measuring && styles$50.measuring, positioning === 'above' && styles$50.positionedAbove);
        const contentStyles = measuring ? undefined : { maxHeight: desiredHeight };
        const tipMarkup = !measuring ? createElement('div', { style: tipStyle, className: styles$50.Tip }) : null;
        return createElement(
            'div',
            Object.assign({ className: containerClassName }, layer.props),
            tipMarkup,
            createElement(
                'div',
                { className: styles$50.Wrapper },
                createElement(
                    'div',
                    { id: id, role: 'tooltip', className: styles$50.Content, style: contentStyles },
                    children
                )
            )
        );
    }
}
__decorate([autobind], TooltipOverlay.prototype, "renderOverlay", null);
__decorate([autobind], TooltipOverlay.prototype, "renderTooltip", null);
function calculateTipPosition(activatorRectXAxisCenter, left) {
    return { left: activatorRectXAxisCenter - left };
}

const getUniqueID$8 = createUniqueIDFactory('TooltipContent');
let Tooltip$1 = class Tooltip extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            active: false
        };
        this.id = getUniqueID$8();
    }
    componentDidMount() {
        this.setAccessibilityAttributes();
    }
    componentDidUpdate() {
        this.setAccessibilityAttributes();
    }
    renderLayer() {
        const { id, activatorNode } = this;
        if (activatorNode == null) {
            return null;
        }
        const { preferredPosition = 'below', active, light, content } = this.props;
        return createElement(
            TooltipOverlay,
            { id: id, preferredPosition: preferredPosition, activator: activatorNode, active: active || this.state.active, onClose: noop, light: light },
            createElement(
                'div',
                { className: styles$50.Label },
                content
            )
        );
    }
    render() {
        const { activatorWrapper: WrapperComponent = 'span' } = this.props;
        return createElement(
            WrapperComponent,
            { onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave, ref: this.setActivator },
            this.props.children
        );
    }
    setActivator(node) {
        if (node == null) {
            this.activatorNode = null;
            this.activatorContainer = null;
            return;
        }
        this.activatorNode = node.firstElementChild;
        this.activatorContainer = node;
    }
    handleFocus() {
        this.setState({ active: true });
    }
    handleBlur() {
        this.setState({ active: false });
    }
    handleMouseEnter() {
        this.setState({ active: true });
    }
    handleMouseLeave() {
        this.setState({ active: false });
    }
    setAccessibilityAttributes() {
        const { activatorContainer, id } = this;
        if (activatorContainer == null) {
            return;
        }
        const firstFocusable = findFirstFocusableNode(activatorContainer);
        const accessibilityNode = firstFocusable || activatorContainer;
        accessibilityNode.tabIndex = 0;
        accessibilityNode.setAttribute('aria-describedby', id);
    }
};
__decorate([autobind], Tooltip$1.prototype, "setActivator", null);
__decorate([autobind], Tooltip$1.prototype, "handleFocus", null);
__decorate([autobind], Tooltip$1.prototype, "handleBlur", null);
__decorate([autobind], Tooltip$1.prototype, "handleMouseEnter", null);
__decorate([autobind], Tooltip$1.prototype, "handleMouseLeave", null);
Tooltip$1 = __decorate([layeredComponent({ idPrefix: 'Tooltip' })], Tooltip$1);
var Tooltip$2 = Tooltip$1;

function useLinkComponent(LinkComponent) {
    UnstyledLink$1.use(LinkComponent);
}

export { Keys, AccountConnection$1 as AccountConnection, ActionList$1 as ActionList, Avatar$1 as Avatar, Badge$1 as Badge, Banner$1 as Banner, Button$1 as Button, buttonFrom, buttonsFrom, ButtonGroup$1 as ButtonGroup, CalloutCard$1 as CalloutCard, Caption$1 as Caption, Card$1 as Card, Checkbox$1 as Checkbox, ChoiceList$1 as ChoiceList, Collapsible$1 as Collapsible, ColorPicker$1 as ColorPicker, rgbToHex, rgbToHsb, hsbToRgb, hsbToHex, rgbString, rgbaString, DatePicker$1 as DatePicker, Months, DescriptionList$1 as DescriptionList, DisplayText$1 as DisplayText, EmptyState$1 as EmptyState, EventListener$1 as EventListener, FooterHelp$1 as FooterHelp, FormLayout$1 as FormLayout, Heading$1 as Heading, Icon$1 as Icon, Image$1 as Image, KeyboardKey$1 as KeyboardKey, KeypressListener$1 as KeypressListener, Label$1 as Label, Layout$1 as Layout, Link$1 as Link, ContentList as List, Page$1 as Page, PageActions$1 as PageActions, Pagination$1 as Pagination, Popover$2 as Popover, RadioButton$1 as RadioButton, ResourceList$1 as ResourceList, Scrollable$1 as Scrollable, Select$1 as Select, SettingToggle$1 as SettingToggle, Stack$1 as Stack, Subheading$1 as Subheading, Tabs$1 as Tabs, Tag$1 as Tag, TextContainer$1 as TextContainer, TextField$1 as TextField, TextStyle$1 as TextStyle, Thumbnail$1 as Thumbnail, Tooltip$2 as Tooltip, UnstyledLink$1 as UnstyledLink, VisuallyHidden$1 as VisuallyHidden, useLinkComponent };
